{
  "README.html": {
    "href": "README.html",
    "title": "netcore-sci | netcore-sci",
    "keywords": "netcore-sci .NET core sci API Documentation Changelog Build Examples 0001 0002 0003 Tests LoopTest_0014 LoopTest_0021 PolygonTest_0007 Quickstart Basic concepts Side effects Tolerances Vector3D Line3D Arc3D CoordinateSystem3D Loop Face Edges Geometry Unit tests How this project was built Documentation (github pages) Build and view locally Build and commit into docs branch IOT Build mkdir ~/opensource git clone https://github.com/devel0/netcore-sci.git dotnet build Examples 0001 create a dxf result dxf 0002 detect polygons ( line, arcs ) intersection loops result dxf yellow âˆ© green 0003 detect polygons ( line, arcs ) intersection loops when edges overlaps result dxf yellow âˆ© green Tests ðŸ‘‰ unit tests still a good place to find some example about library usage. LoopTest_0014 yellow - green LoopTest_0021 yellow âˆ© green dxf yellow - green dxf green - yellow dxf yellow âˆª green dxf PolygonTest_0007 offsets the existing polyline ( cyan ) by specified amount using a reference point to disambiguate the offset side ( yellow, green ). Quickstart nuget package api global usings: global using SearchAThing.Ext; global using static SearchAThing.Ext.Toolkit; global using SearchAThing.Sci; global using static SearchAThing.Sci.Toolkit; global using static SearchAThing.Sci.Constants; Basic concepts Side effects If not explicitly described in function documentation with a declaration of (side effects) all netcore-sci classes operates without side effects on the object. For example: Vector3D a(1, 2, 3); var b = a.SetX(10); The vector a created with X:1, Y:2, Z:3 will subjected to a SetX(10) but the vector a itself not changes, it still equals to (1,2,3); instead SetX returns a new instance (10, 2, 3). Tolerances any function in this library that involves some test of comparision between numbers requires as first argument a tolerance parameter the tolerance depends on the domain application you are working on, for example if you work on mm lengths then a 1e-1 could enough when working with normalized vector3d regardless of the domain application the constant NormalizedLengthTolerance should used ( it has a 1e-4 default value that is enough to work with double and floats ) note that the tolerance doesn't influence for example in how accurate is the result of an intersection because the value is computed with maximum resolution that doubles provides; tolerance are used only when tests ( EqualsTol, ... ) are used into internal algorithms to make decisions. Vector3D used to represent 3d coordinate ( X, Y, Z ) but used also to keep dummy 2d coordinate ( X, Y, 0 ) length of a vector3d is the distance of the point from wcs origin (0,0,0) Line3D defined by a From vector3d ( line application point ) and an extension from there through a vector V To = From + V line3d can be created giving (From, To) or (From, V) specifying overriden method with Line3DConstructMode.PointAndVector extension methods allow to create line from a vector p and using p.LineTo(Vector3D to) p.LineV(Vector3D v) : To = p+v p.LineDir(Vector3D dir, double len) : To = p + dir * len line3d represent an infine line, semiline or segment depending on the usage, for example intersect methods allow to specify the behavior ( default: infinite lines ) Arc3D circle3d inherit from arc3d arc is defined in the range [AngleFrom, AngleTo) rotating right-hand over its coordinate system zaxis arc angles are normalized so that they fall into range [0, 2pi) CoordinateSystem3D defined by vector3d origin, basex, basey, basez origin is used in vectro3d ToUCS(), ToWCS() methods to translate between different ucs origins ( WCS origin is 0,0,0 ) basex,y,z are linearly independant normalized vector3d CS can be built in various manners by giving an origin and a single vector3D (the normal) then by using an arbitrary axis algorithm it detects appropriate x-y axes. ( used in dxf for example because allow to save 1 vector3d ) by giving an origin and two vectors v1, v2 by specifying a SmartCsMode to instruct the wizard on how to consider these in relationship ( normally the smart mode X_YQ consider that v1 is the wanted X axis while v2 is in the xy plane and must not be parallel to the first v1; to obtain a numerical stable cs the angle v1,v2 should near to PI/2 but this depend on the application you are working on, in some cases 5-10deg could enough to compute the normal, then yaxis will be back computed from the z cross x ). by giving origin and normalized base vectors Loop actually implements only planar loop with edges such as Line3D, Arc3D. edges inside loop are ensured to be ordered. Face can have one or more loops; first loop is the outer. supports boolean ( intersection, difference, union ) of 3d planar loop faces. Edges is an interface for Loop purpose implemented over basic entities such as Line3D and Arc3D Geometry basic abstract type for geometries contains definition of SGeomFrom and SGeomTo that will be used by inherited IEdge interface implemented objects such as Line3D and Arc3D and allow to state the sense of the edge sense == true â‡’ SGeomFrom == GeomFrom âˆ§ SGeomTo == GeomTo sense == false â‡’ SGeomFrom == GeomTo âˆ§ SGeomTo == GeomFrom Unit tests debugging unit tests from vscode just run debug test from code lens balloon executing all tests from solution root folder dotnet test testing coverage from vscode run task ( ctrl+shift+p ) Tasks: Run Task then test with coverage or use provided script ./generate-coverage.sh extensions required to watch coverage ( Coverage Gutters ) How this project was built mkdir netcore-sci cd netcore-sci mkdir src examples cd src dotnet new classlib -n netcore-sci mv netcore-sci sci cd .. cd examples dotnet new console --use-program-main -n example mv example/example.csproj example/example-0001.csproj mv example example-0001 dotnet new xunit -n test cd test dotnet add reference ../sci/netcore-sci.csproj # enable test coverage collector # to view in vscode ( \"Coverage Gutters\" ext ) run `./test-coverage` then `C-S-p` Coverage Gutters: Watch dotnet add package coverlet.collector dotnet add package coverlet.msbuild cd .. cd .. dotnet new sln dotnet sln add src/sci src/test dotnet sln add examples/example-0001 examples/example-0002 examples/example-0003 dotnet build Documentation (github pages) Configured through Settings/Pages on Branch docs ( path /docs ). while main branch exclude \"docs\" with .gitignore the docs branch doesn't Build and view locally ./doc build ./doc serve ./doc view Build and commit into docs branch ./doc commit IOT iot-sci is a c++ port of this library."
  },
  "api/SearchAThing.Sci.Arc3D.html": {
    "href": "api/SearchAThing.Sci.Arc3D.html",
    "title": "Class Arc3D | netcore-sci",
    "keywords": "Class Arc3D Namespace SearchAThing.Sci Assembly netcore-sci.dll base geometry for arc 3d entities. the CS origin is the Center of the arc. the CS basex, basey forms the arc plane. angles start, end are normalized [0,2pi) measured as angle from the basex right-hand rotating around cs basez. the arc coverage goes from the angle start point toward angle end point right-hand rotating arond cs basez. while the CS right hand rule allow to know the effective arc coverage Sense information allow to know the effective edge orientation. public class Arc3D : Edge Inheritance object Geometry Edge Arc3D Derived Circle3D Inherited Members Edge.CopyFrom(Edge) Edge.Sense Edge.SGeomFrom Edge.SGeomTo Edge.OtherEndpoint(double, Vector3D) Edge.EndpointMatches(double, Vector3D, Vector3D) Edge.EndpointMatches(double, Vector3D) Edge.CheckSense(double, Edge) Geometry.GeomType object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors Arc3D(Arc3D) build a copy of given arc public Arc3D(Arc3D arc) Parameters arc Arc3D Arc3D(CoordinateSystem3D, double, double, double) construct 3d arc public Arc3D(CoordinateSystem3D cs, double r, double angleRadStart, double angleRadEnd) Parameters cs CoordinateSystem3D coordinate system with origin at arc center, XY plane of cs contains the arc, angle is 0 at cs x-axis and increase right-hand around cs z-axis r double arc radius angleRadStart double arc angle start (rad). is not required that start angle less than end. It will normalized 0-2pi angleRadEnd double arc angle end (rad). is not require that end angle great than start. It will normalized 0-2pi Arc3D(Vector3D, Vector3D, Vector3D) build 3d arc by given 3 points (angles 0,2pi) protected Arc3D(Vector3D p1, Vector3D p2, Vector3D p3) Parameters p1 Vector3D first constraint point p2 Vector3D second constraint point p3 Vector3D third constraint point Arc3D(double, CoordinateSystem3D, double, Vector3D, Vector3D) build arc with given cs, radius goind from,to vectors public Arc3D(double tol, CoordinateSystem3D cs, double r, Vector3D from, Vector3D to) Parameters tol double cs CoordinateSystem3D r double from Vector3D to Vector3D Arc3D(double, Vector3D, Vector3D, Vector3D) Build arc by 3 given points. Resulting simplified CS and normalized [0,2pi) AngleStart and AngleEnd will be choosen to meet follow requirements: fromPt = CS.Origin + (Radius * CS.BaseX).RotateAboutAxis(CS.BaseZ, AngleStart) ; toPt = CS.Origin + (Radius * CS.BaseX).RotateAboutAxis(CS.BaseZ, AngleEnd) public Arc3D(double tol, Vector3D fromPt, Vector3D insidePt, Vector3D toPt) Parameters tol double length tolerance fromPt Vector3D arc start point insidePt Vector3D arc inside point (ideally midpoint) toPt Vector3D arc end point Properties A0ProgeCadScript public string A0ProgeCadScript { get; } Property Value string A0QCadScript public string A0QCadScript { get; } Property Value string Angle Arc (rad) angle length. angle between start-end or end-start depending on what start is less than end or not public double Angle { get; } Property Value double AngleEnd end angle (rad) [0-2pi) respect cs xaxis rotating around cs zaxis note that start angle can be greather than end angle public double AngleEnd { get; protected set; } Property Value double AngleEndDeg public double AngleEndDeg { get; } Property Value double AngleStart start angle (rad) [0-2pi) respect cs xaxis rotating around cs zaxis note that start angle can be greather than end angle public double AngleStart { get; protected set; } Property Value double AngleStartDeg public double AngleStartDeg { get; } Property Value double CS coordinate system centered in arc center angle is 0 at X axis angle increase rotating right-hand on Z axis public CoordinateSystem3D CS { get; } Property Value CoordinateSystem3D Center public Vector3D Center { get; } Property Value Vector3D ChordTriangleArea Area of chord triangle public double ChordTriangleArea { get; } Property Value double CircularSectorArea Area of circular sector public double CircularSectorArea { get; } Property Value double DxfEntity dxf entity representing this geom public override EntityObject DxfEntity { get; } Property Value EntityObject From point at angle start public Vector3D From { get; } Property Value Vector3D GeomFrom start point public override Vector3D GeomFrom { get; } Property Value Vector3D GeomTo end point public override Vector3D GeomTo { get; } Property Value Vector3D Length Length of Arc from start to end public override double Length { get; } Property Value double MidPoint mid point eval as arc point at angle start + arc angle/2 public override Vector3D MidPoint { get; } Property Value Vector3D Radius radius of arc public double Radius { get; } Property Value double Segment return From,To segment public Line3D Segment { get; } Property Value Line3D SegmentArea Segment area ( CircularSectorArea - ChordTriangleArea ) public double SegmentArea { get; } Property Value double SensedAngleEnd public double SensedAngleEnd { get; } Property Value double SensedAngleEndDeg public double SensedAngleEndDeg { get; } Property Value double SensedAngleStart public double SensedAngleStart { get; } Property Value double SensedAngleStartDeg public double SensedAngleStartDeg { get; } Property Value double To point at angle end public Vector3D To { get; } Property Value Vector3D Vertexes vertexes of this geom ( can be 1 for points, 2 for line/arc/circles ) public override IEnumerable<Vector3D> Vertexes { get; } Property Value IEnumerable<Vector3D> Methods BBox(double) compute wcs bbox executing a recursive bisect search of min and max public override BBox3D BBox(double tol) Parameters tol double Returns BBox3D Bulge(double) http://www.lee-mac.com/bulgeconversion.html public double Bulge(double tol) Parameters tol double length tolerance Returns double arc buldge value CentreOfMass(out double) centre of mass of circular segment public Vector3D CentreOfMass(out double A) Parameters A double arc area Returns Vector3D location of arc centre of mass Contains(double, Vector3D, bool) states if given point relies on this arc perimeter or shape depending on arguments public virtual bool Contains(double tol, Vector3D pt, bool onlyPerimeter) Parameters tol double length tolerance pt Vector3D point to check onlyPerimeter bool if true it checks if point is on perimeter; if false it will check in area too Returns bool Contains(double, Vector3D, bool, bool) statis if given point contained in arc perimeter/shape or circle perimeter/shape depending on specified mode protected bool Contains(double tol, Vector3D pt, bool inArcAngleRange, bool onlyPerimeter) Parameters tol double len tolerance pt Vector3D point to test inArcAngleRange bool true if point angle must contained in arc angles, false to test like a circle onlyPerimeter bool true to test point contained only in perimeter, false to test also contained in area Returns bool true if arc contains given pt Copy() create copy of this geometry. public override Geometry Copy() Returns Geometry Remarks it's required to call base.CopyFrom(other) to ensure geometry properties to be copied. Discretize(double) retrieve a discretized representation of this arc public IEnumerable<Line3D> Discretize(double maxLineAngleRadStep) Parameters maxLineAngleRadStep double lines angles max Returns IEnumerable<Line3D> Divide(int, bool) split arc into pieces and retrieve split points /// public override IEnumerable<Vector3D> Divide(int cnt, bool include_endpoints = false) Parameters cnt int nr of piece include_endpoints bool if true returns also boundary points Returns IEnumerable<Vector3D> EdgeContainsPoint(double, Vector3D) States if edge contains given point on its perimeter public override bool EdgeContainsPoint(double tol, Vector3D pt) Parameters tol double pt Vector3D Returns bool EqualsTol(double, Arc3D) Checks if two arcs are equals ( it checks agains swapped from-to too ) public bool EqualsTol(double tol, Arc3D other) Parameters tol double length tolerance other Arc3D other arc Returns bool trus if two arcs equals GeomEquals(double, Geometry, bool) states if this geom equals to given other public override bool GeomEquals(double tol, Geometry other, bool checkSense = false) Parameters tol double length tolerance other Geometry other geom checkSense bool if false two geometry with different sense but same space coverage are considered equals Returns bool GeomIntersect(double, Geometry, GeomSegmentMode, GeomSegmentMode) find intersections between this and another geometry resulting in zero or more geometries. public override IEnumerable<Geometry> GeomIntersect(double tol, Geometry _other, GeomSegmentMode thisSegmentMode, GeomSegmentMode otherSegmentMode) Parameters tol double _other Geometry thisSegmentMode GeomSegmentMode if this is Line3D specifies how to consider otherSegmentMode GeomSegmentMode if other is Line3D specifies how to consider Returns IEnumerable<Geometry> Intersect(double, Arc3D, bool) finds intersection points between two arcs public IEnumerable<Vector3D> Intersect(double tol, Arc3D other, bool onlyPerimeter) Parameters tol double length tolerance other Arc3D other arc onlyPerimeter bool true to test point contained only in perimeter, false to test also contained in area Returns IEnumerable<Vector3D> Intersect(double, CoordinateSystem3D, bool, bool) find ips of intersect this arc to the given cs plane; return empty set if arc cs plane parallel to other given cs public IEnumerable<Vector3D> Intersect(double tol, CoordinateSystem3D cs, bool onlyPerimeter, bool inArcAngleRange) Parameters tol double len tolerance cs CoordinateSystem3D cs xy plane onlyPerimeter bool if false it will check in the arc area too, otherwise only on arc perimeter inArcAngleRange bool if true find ips only for arc angle range Returns IEnumerable<Vector3D> sample Remarks unit test Intersect(double, Line3D, bool, bool) find ips of intersection between this arc and given line public virtual IEnumerable<Vector3D> Intersect(double tol, Line3D l, bool onlyPerimeter, bool lineSegmentMode) Parameters tol double length tolerance l Line3D line onlyPerimeter bool check intersection only along perimeter; if false it will check intersection along arc area shape border too lineSegmentMode bool if true treat given line as segment; if false as infinite line Returns IEnumerable<Vector3D> intersection points between this arc and given line Intersect(double, Line3D, bool, bool, bool) states if this arc intersect given line public IEnumerable<Vector3D> Intersect(double tol, Line3D l, bool onlyPerimeter, bool lineSegmentMode, bool arcSegmentMode) Parameters tol double arc tolerance l Line3D line to test intersect onlyPerimeter bool check intersection only along perimeter; if false it will check intersection along arc area shape border too lineSegmentMode bool if true line treat as segment instead of infinite arcSegmentMode bool if true arc treat as circle Returns IEnumerable<Vector3D> Move(Vector3D) create an arc copy with origin moved public override Geometry Move(Vector3D delta) Parameters delta Vector3D new arc origin delta Returns Geometry MoveEnd(double, EdgeEnd, Vector3D) extends edge endpoint toward new given one. returns null if edge can't extends toward new given end. public override Edge? MoveEnd(double tol, EdgeEnd end, Vector3D newEnd) Parameters tol double end EdgeEnd newEnd Vector3D Returns Edge Offset(double, Vector3D, double) create offseted arc toward refPt for given offset. public override Edge Offset(double tol, Vector3D refPt, double offset) Parameters tol double refPt Vector3D offset double Returns Edge Perpendicular(double, Vector3D) Build a perpendicular vector to this arc starting from the given point p. public Line3D? Perpendicular(double tol, Vector3D p) Parameters tol double p Vector3D Returns Line3D ProgeCadScript(bool) public override string ProgeCadScript(bool final = true) Parameters final bool Returns string Project(double, Plane3D) project this arc to given projection plane public override Edge Project(double tol, Plane3D prjPlane) Parameters tol double prjPlane Plane3D Returns Edge Project(double, Vector3D, bool) project given point p to this arc. returns null if ip falls outside arc perimeter and only_arc:true argument or p in the arc plane public override Vector3D? Project(double tol, Vector3D p, bool arcSegmentMode = true) Parameters tol double p Vector3D arcSegmentMode bool Returns Vector3D PtAngle(double, Vector3D) return the angle (rad) of the point respect cs x axis rotating around cs z axis to reach given point angle alignment public double PtAngle(double tol, Vector3D pt) Parameters tol double length tolerance pt Vector3D point to query angle respect csx axis for Returns double PtAtAngle(double) point on the arc circumnfere at given angle (rotating cs basex around cs basez) note: it start public Vector3D PtAtAngle(double angleRad) Parameters angleRad double Returns Vector3D QCadScript(bool) qcad 2d script public override string QCadScript(bool final = true) Parameters final bool adds QQ command Returns string Split(double, IEnumerable<Vector3D>) returns this arc splitted by break points maintaining order from, to as this Start, End angle. precondition: breaks must lie on the arc angle range public override IEnumerable<Geometry> Split(double tol, IEnumerable<Vector3D> breaks) Parameters tol double length tolerance breaks IEnumerable<Vector3D> Returns IEnumerable<Geometry> Split(double, IEnumerable<Vector3D>, bool) create a set of subarc from this by splitting through given split points split point are not required to be on perimeter of the arc ( a center arc to point line will split ) generated subarcs will start from this arc angleFrom and contiguosly end to angleTo public IEnumerable<Arc3D> Split(double tol, IEnumerable<Vector3D> _splitPts, bool validate_pts = false) Parameters tol double arc length tolerance _splitPts IEnumerable<Vector3D> point where split arc validate_pts bool if true split only for split points on arc perimeter Returns IEnumerable<Arc3D> ToCircle3D(double) public Circle3D ToCircle3D(double tol) Parameters tol double Returns Circle3D ToString() public override string ToString() Returns string ToString(int) public override string ToString(int digits = 3) Parameters digits int Returns string ToggleSense() public Arc3D ToggleSense() Returns Arc3D"
  },
  "api/SearchAThing.Sci.Arc3DEqualityComparer.html": {
    "href": "api/SearchAThing.Sci.Arc3DEqualityComparer.html",
    "title": "Class Arc3DEqualityComparer | netcore-sci",
    "keywords": "Class Arc3DEqualityComparer Namespace SearchAThing.Sci Assembly netcore-sci.dll checks if arcs share same plane, origin, radius, angle start-end public class Arc3DEqualityComparer : IEqualityComparer<Arc3D> Inheritance object Arc3DEqualityComparer Implements IEqualityComparer<Arc3D> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Arc3DEqualityComparer(double) arc 3d eq comparer public Arc3DEqualityComparer(double _tol) Parameters _tol double length tolerance Methods Equals(Arc3D?, Arc3D?) public bool Equals(Arc3D? x, Arc3D? y) Parameters x Arc3D y Arc3D Returns bool GetHashCode(Arc3D) public int GetHashCode(Arc3D obj) Parameters obj Arc3D Returns int"
  },
  "api/SearchAThing.Sci.BBox3D.html": {
    "href": "api/SearchAThing.Sci.BBox3D.html",
    "title": "Class BBox3D | netcore-sci",
    "keywords": "Class BBox3D Namespace SearchAThing.Sci Assembly netcore-sci.dll Bounding Box. Initially empty, each added point will increase the extension if min or max exceed actual bbox limits. It works within wcs. public class BBox3D Inheritance object BBox3D Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors BBox3D() construct empy bbox public BBox3D() BBox3D(BBox3D) construct a copy of bbox public BBox3D(BBox3D other) Parameters other BBox3D source bbox BBox3D(Vector3D, double) construct bbox that contains pt at center and with given radius public BBox3D(Vector3D pt, double radius) Parameters pt Vector3D radius double BBox3D(IEnumerable<Vector3D>) construct bbox with given points public BBox3D(IEnumerable<Vector3D> pts) Parameters pts IEnumerable<Vector3D> points to add to the bbox Properties CadScript script to paste in cad to draw bbox public string CadScript { get; } Property Value string Coords2D build a 4 point bbox coords for 2D using Z=Min.Z public IEnumerable<Vector3D> Coords2D { get; } Property Value IEnumerable<Vector3D> Coords3D build 8 coords 3d of current bbox public IEnumerable<Vector3D> Coords3D { get; } Property Value IEnumerable<Vector3D> Empty public static BBox3D Empty { get; } Property Value BBox3D IsEmpty states if bbox empty public bool IsEmpty { get; } Property Value bool Max Max coord of bbox resulting by all inserted points public Vector3D Max { get; } Property Value Vector3D Middle middle point of bbox = (Min+Max)/2 ( Zero if empty ) public Vector3D Middle { get; } Property Value Vector3D middle point of bbox Min Min coord of bbox resulting by all inserted points public Vector3D Min { get; } Property Value Vector3D Points (not cached) retrieve ordered set of points for this bbox (0..4) first face (5..7) other face [0] = (Min.X, Min.Y, Min.Z) [1] = (Max.X, Min.Y, Min.Z) [2] = (Max.X, Max.Y, Min.Z) [3] = (Min.X, Max.Y, Min.Z) [4] = (Min.X, Min.Y, Max.Z) [5] = (Max.X, Min.Y, Max.Z) [6] = (Max.X, Max.Y, Max.Z) [7] = (Min.X, Max.Y, Max.Z) public IReadOnlyList<Vector3D> Points { get; } Property Value IReadOnlyList<Vector3D> Size Size of bbox as Max-Min point distance ( Zero if empty) public Vector3D Size { get; } Property Value Vector3D Methods AddMargin(Vector3D) create new bbox extending by subtract margin to Min and by add to Max public BBox3D AddMargin(Vector3D margin) Parameters margin Vector3D Returns BBox3D ApplyUnion(params Vector3D[]) add given points to current bbox with side effects public void ApplyUnion(params Vector3D[] pts) Parameters pts Vector3D[] points to add ApplyUnion(IEnumerable<Vector3D>) add given points to current bbox with side effects public void ApplyUnion(IEnumerable<Vector3D> pts) Parameters pts IEnumerable<Vector3D> points to add Clear() reset to empty bbox public void Clear() Contains(double, BBox3D, bool, bool) states if given other bbox contained in this public bool Contains(double tol, BBox3D other, bool strictly = false, bool testZ = true) Parameters tol double tolerance against Min, Max comparision other BBox3D other bbox to check if contained in this strictly bool if true it checks this bbox is stricly contained into given other testZ bool if false min,max test of Z isn't evaluated (useful for planar entities bboxes tests) Returns bool true if given other bbox contained in this one Contains(double, Vector3D) states if given point contained in this bbox public bool Contains(double tol, Vector3D p) Parameters tol double tolerance against Min, Max comparision p Vector3D point to check if contained in this bbox Returns bool true if given point contained in this bbox Contains2D(double, Vector3D) states if given point is contained in this bbox excluding Z evaluation public bool Contains2D(double tol, Vector3D p) Parameters tol double tolerance against Min, Max comparision p Vector3D point to check if contained in this bbox (Z ignored) Returns bool true if given point (Z ignored) contained in this bbox DrawCuboid(DxfObject, Layer?) public IEnumerable<Face3D> DrawCuboid(DxfObject dxfObj, Layer? layer = null) Parameters dxfObj DxfObject layer Layer Returns IEnumerable<Face3D> EqualsTol(double, BBox3D) states if this bbox equals to the other one public bool EqualsTol(double tol, BBox3D other) Parameters tol double tolerance against Min, Max comparision other BBox3D other bbox to compare for equality Returns bool true if given bbox equals this one Faces(double) retrieve 6 faces (bottom, top, left, right, front, back) of bbox. (see Points property documentation for vertex enumeration), faces are: public IEnumerable<Plane3DRegion> Faces(double tol) Parameters tol double Returns IEnumerable<Plane3DRegion> Intersect(double, Line3D) find intersection points of given ray to this bbox faces public IEnumerable<Vector3D> Intersect(double tol, Line3D ray) Parameters tol double length tolerance ray Line3D ray to test if intersect one or more of this bbox faces Returns IEnumerable<Vector3D> intersection points Scale(Vector3D) scale all bbox points Min,Max respect to the center public BBox3D Scale(Vector3D factor) Parameters factor Vector3D scale factor Returns BBox3D new bbox scaled Scale(double) scale all bbox points Min,Max respect to the center public BBox3D Scale(double factor) Parameters factor double scale factor Returns BBox3D new bbox scaled ToFace3DList() public IEnumerable<Face3D> ToFace3DList() Returns IEnumerable<Face3D> ToString() stringify bbox as Max-Min=Size public override string ToString() Returns string Union(BBox3D) union of this bbox with another public BBox3D Union(BBox3D other) Parameters other BBox3D other bbox to add to this Returns BBox3D new bbox resulting from the union of this with given other one Union(Vector3D) union of this bbox with given point public BBox3D Union(Vector3D p) Parameters p Vector3D point to add to this bbox copy Returns BBox3D new bbox with given point added to"
  },
  "api/SearchAThing.Sci.Circle3D.html": {
    "href": "api/SearchAThing.Sci.Circle3D.html",
    "title": "Class Circle3D | netcore-sci",
    "keywords": "Class Circle3D Namespace SearchAThing.Sci Assembly netcore-sci.dll Specialized version of Arc3D with StartAngle=0 and EndAngle=2PI public class Circle3D : Arc3D Inheritance object Geometry Edge Arc3D Circle3D Inherited Members Arc3D.EdgeContainsPoint(double, Vector3D) Arc3D.Split(double, IEnumerable<Vector3D>) Arc3D.MidPoint Arc3D.ProgeCadScript(bool) Arc3D.A0QCadScript Arc3D.A0ProgeCadScript Arc3D.Project(double, Plane3D) Arc3D.Offset(double, Vector3D, double) Arc3D.MoveEnd(double, EdgeEnd, Vector3D) Arc3D.Copy() Arc3D.ToggleSense() Arc3D.Vertexes Arc3D.GeomFrom Arc3D.GeomTo Arc3D.Divide(int, bool) Arc3D.BBox(double) Arc3D.GeomIntersect(double, Geometry, GeomSegmentMode, GeomSegmentMode) Arc3D.GeomEquals(double, Geometry, bool) Arc3D.CS Arc3D.Radius Arc3D.AngleStart Arc3D.AngleStartDeg Arc3D.SensedAngleStart Arc3D.SensedAngleStartDeg Arc3D.AngleEnd Arc3D.AngleEndDeg Arc3D.SensedAngleEnd Arc3D.SensedAngleEndDeg Arc3D.Angle Arc3D.PtAtAngle(double) Arc3D.PtAngle(double, Vector3D) Arc3D.From Arc3D.To Arc3D.Segment Arc3D.EqualsTol(double, Arc3D) Arc3D.Bulge(double) Arc3D.Contains(double, Vector3D, bool, bool) Arc3D.Center Arc3D.Perpendicular(double, Vector3D) Arc3D.Project(double, Vector3D, bool) Arc3D.ToCircle3D(double) Arc3D.CircularSectorArea Arc3D.ChordTriangleArea Arc3D.SegmentArea Arc3D.CentreOfMass(out double) Arc3D.Intersect(double, Arc3D, bool) Arc3D.Intersect(double, Line3D, bool, bool, bool) Arc3D.Intersect(double, CoordinateSystem3D, bool, bool) Arc3D.ToString() Arc3D.ToString(int) Arc3D.Split(double, IEnumerable<Vector3D>, bool) Arc3D.Discretize(double) Edge.CopyFrom(Edge) Edge.Sense Edge.SGeomFrom Edge.SGeomTo Edge.OtherEndpoint(double, Vector3D) Edge.EndpointMatches(double, Vector3D, Vector3D) Edge.EndpointMatches(double, Vector3D) Edge.CheckSense(double, Edge) Geometry.GeomType object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors Circle3D(Arc3D) create circle from given arc public Circle3D(Arc3D arc) Parameters arc Arc3D arc used to build circle Circle3D(CoordinateSystem3D, double) create a circle in the given cs with given radius public Circle3D(CoordinateSystem3D cs, double r) Parameters cs CoordinateSystem3D r double Circle3D(Vector3D, Vector3D, Vector3D) Build 3d circle that intersect p1,p2,p3 ( the inside CS will centered in the circle center and Xaxis toward p1 ) public Circle3D(Vector3D p1, Vector3D p2, Vector3D p3) Parameters p1 Vector3D p2 Vector3D p3 Vector3D Properties Area Circle area public double Area { get; } Property Value double DxfEntity build dxf circle public override EntityObject DxfEntity { get; } Property Value EntityObject Length Circle perimeter public override double Length { get; } Property Value double Methods CircleRTanP(double, Vector3D, Line3D, double) build 3d circle through point p, tangent to given t line, with given radius r they can be two public static IEnumerable<Circle3D> CircleRTanP(double tol, Vector3D p, Line3D t, double r) Parameters tol double length tolerance p Vector3D passing point t Line3D tangent line r double circle radius Returns IEnumerable<Circle3D> CirclesTan12P(double, Line3D, Line3D, Vector3D) build 3d circle that tangent to lines t1,t2 and that intersects point p note: point p must contained in one of t1,t2 circle will be inside region t1.V toward t2.V they are 4 circles public static IEnumerable<Circle3D> CirclesTan12P(double tol, Line3D t1, Line3D t2, Vector3D p) Parameters tol double length tolerance t1 Line3D first tangent line t2 Line3D second tangent line p Vector3D point on t1 xor t2 to state the circle radius Returns IEnumerable<Circle3D> Contains(double, Vector3D, bool) states if given point relies on this arc perimeter or shape depending on arguments public override bool Contains(double tol, Vector3D pt, bool onlyPerimeter) Parameters tol double length tolerance pt Vector3D point to check onlyPerimeter bool if true it checks if point is on perimeter; if false it will check in area too Returns bool InscribedPolygon(double, int) creates circle inscribed polygon and retrieve vertexes ( last == first ) public IEnumerable<Vector3D> InscribedPolygon(double tol, int segmentCount = 360) Parameters tol double length tolerance segmentCount int count of inscribed polygon segments ( must at least 3; default is 360 ) Returns IEnumerable<Vector3D> coordinates of polygon vertices ( last == first ) Intersect(double, Circle3D) intersect this circle with given other; pre-requisite: circles are not the same one ; actually implemented only for coplanar circles public IEnumerable<Vector3D> Intersect(double tol, Circle3D other) Parameters tol double len tolerance other Circle3D other circle Returns IEnumerable<Vector3D> Intersect(double, Line3D, bool, bool) intersect this 3d circle with given 3d line public override IEnumerable<Vector3D> Intersect(double tol, Line3D l, bool onlyPerimeter, bool lineSegmentMode) Parameters tol double l Line3D onlyPerimeter bool lineSegmentMode bool Returns IEnumerable<Vector3D> Move(Vector3D) create a circle copy with origin moved public override Geometry Move(Vector3D delta) Parameters delta Vector3D new circle origin delta Returns Geometry QCadScript(bool) qcad 2d script public override string QCadScript(bool final = true) Parameters final bool adds QQ command Returns string"
  },
  "api/SearchAThing.Sci.CircleTangentType.html": {
    "href": "api/SearchAThing.Sci.CircleTangentType.html",
    "title": "Enum CircleTangentType | netcore-sci",
    "keywords": "Enum CircleTangentType Namespace SearchAThing.Sci Assembly netcore-sci.dll public enum CircleTangentType Fields Exterior = 0 Interior = 1"
  },
  "api/SearchAThing.Sci.ComputationQueue-1.html": {
    "href": "api/SearchAThing.Sci.ComputationQueue-1.html",
    "title": "Class ComputationQueue<T> | netcore-sci",
    "keywords": "Class ComputationQueue<T> Namespace SearchAThing.Sci Assembly netcore-sci.dll helper circular queue manager for computation. at constructor the maxSize ( default=3 ) can be specified to allow retrieval of previous computed items public class ComputationQueue<T> where T : class Type Parameters T type that hold computation data Inheritance object ComputationQueue<T> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ComputationQueue(int) construct a computation queue with given size. if queue size already at maxSize older element will be overwritten. public ComputationQueue(int maxSize = 3) Parameters maxSize int max circular queue size Properties Count actual inserted items in the queue public int Count { get; } Property Value int Current last inserted item public T? Current { get; } Property Value T MaxSize max queue size public int MaxSize { get; } Property Value int Prev previous inserted item ( penultimate ) public T? Prev { get; } Property Value T PrevPrev previous previous inserted item ( antepeunltimate ) public T? PrevPrev { get; } Property Value T Methods Enq(T) insert element in the queue. if queue size already at maxSize older element will be overwritten public void Enq(T d) Parameters d T data to enqueue GetItem(int) retrieve item from the queue public T? GetItem(int prevCnt) Parameters prevCnt int 0 for last inserted, 1 for prev, 2 for prevPrev, ... Returns T prev-th item in the queue"
  },
  "api/SearchAThing.Sci.Constants.html": {
    "href": "api/SearchAThing.Sci.Constants.html",
    "title": "Class Constants | netcore-sci",
    "keywords": "Class Constants Namespace SearchAThing.Sci Assembly netcore-sci.dll public static class Constants Inheritance object Constants Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields NormalizedLengthTolerance tolerance used when comparing normalized vectors. considering range is [0..1] the valued should not smaller than double precision (15-16 digits) ie.1e-15 public const double NormalizedLengthTolerance = 0.0001 Field Value double TwoPIRadTol tolerance over 2PI (rad) public const double TwoPIRadTol = 1E-10 Field Value double"
  },
  "api/SearchAThing.Sci.CoordinateSystem3D.html": {
    "href": "api/SearchAThing.Sci.CoordinateSystem3D.html",
    "title": "Class CoordinateSystem3D | netcore-sci",
    "keywords": "Class CoordinateSystem3D Namespace SearchAThing.Sci Assembly netcore-sci.dll CS with origin and basex, basey, basez orthonormal vectors. WCS coord can be translated to this cs using ToUCS() method. UCS coord can be translated back to wcs using ToWCS() method. public class CoordinateSystem3D Inheritance object CoordinateSystem3D Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors CoordinateSystem3D(Vector3D, Vector3D, CoordinateSystem3DAutoEnum) build coordinate system with given origin and given BaseZ on given vector normal; given normal will subjected to normalization; depending on csAutoType one or another arbitrary axis alghoritm will used to build cs from a point and a normal. public CoordinateSystem3D(Vector3D o, Vector3D normal, CoordinateSystem3DAutoEnum csAutoType = CoordinateSystem3DAutoEnum.AAA) Parameters o Vector3D origin of cs normal Vector3D Z vector of cs csAutoType CoordinateSystem3DAutoEnum auto cs type CoordinateSystem3D(Vector3D, Vector3D, Vector3D, SmartCsMode) Construct a right-hand coordinate system with the given origin and two vector ( not required to be normalized, nor orthogonal ). public CoordinateSystem3D(Vector3D o, Vector3D v1, Vector3D v2, SmartCsMode mode = SmartCsMode.X_YQ) Parameters o Vector3D cs origin v1 Vector3D first vector v2 Vector3D second vector mode SmartCsMode specify how to consider first and second vector to build the cs CoordinateSystem3D(Vector3D, Vector3D, Vector3D, Vector3D) construct a coordinate system with the given origin and orthonormal bases note that given bases MUST already normalized public CoordinateSystem3D(Vector3D o, Vector3D baseX, Vector3D baseY, Vector3D baseZ) Parameters o Vector3D cs origin baseX Vector3D cs X base ( must already normalized ) baseY Vector3D cs Y base ( must already normalized ) baseZ Vector3D cs Z base ( must already normalized ) Fields WCS world cs : basex=(1,0,0) basey=(0,1,0) basez=(0,0,1) public static readonly CoordinateSystem3D WCS Field Value CoordinateSystem3D Remarks unit test XY right handed XY ( Z ) : top view public static readonly CoordinateSystem3D XY Field Value CoordinateSystem3D XZ right handed XZ ( -Y ) : front view public static readonly CoordinateSystem3D XZ Field Value CoordinateSystem3D YZ right handed YZ ( X ) : side view public static readonly CoordinateSystem3D YZ Field Value CoordinateSystem3D Properties BaseX cs x versor ( normalized ) public Vector3D BaseX { get; } Property Value Vector3D BaseY cs y versor ( normalized ) public Vector3D BaseY { get; } Property Value Vector3D BaseZ cs z versor ( normalized ) public Vector3D BaseZ { get; } Property Value Vector3D CadScript script to paste in cad ( axis length = 1 ) public string CadScript { get; } Property Value string Origin origin of cs where x,y,z base vectors applied public Vector3D Origin { get; } Property Value Vector3D csAutoType not null if this cs basex, basey honors cs auto type rule public CoordinateSystem3DAutoEnum? csAutoType { get; } Property Value CoordinateSystem3DAutoEnum? Methods Contains(double, Vector3D, bool) verify if this cs XY plane contains given wcs point public bool Contains(double tol, Vector3D point, bool evalCSOrigin = true) Parameters tol double calc tolerance point Vector3D point to verify evalCSOrigin bool if true CS origin will subtracted before transform test Returns bool true if point contained in cs, else otherwise Equals(double, CoordinateSystem3D) verify is this cs is equals to otherByLayer ( same origin, x, y, z base vectors ) public bool Equals(double tol, CoordinateSystem3D other) Parameters tol double calc tolerance ( for origin check ) other CoordinateSystem3D cs to check equality against Returns bool true if this cs equals the given on, false otherwise Remarks unit test FlipX() retrieve a new cs with same origin but basex flipped (Origin, -BaseX, BaseY, -BaseZ) public CoordinateSystem3D FlipX() Returns CoordinateSystem3D FlipY() retrieve a new cs with same origin but basey flipped (Origin, BaseX, -BaseY, -BaseZ) public CoordinateSystem3D FlipY() Returns CoordinateSystem3D FlipZ() retrieve a new cs with same origin but basez inverted (Origin, BaseX, -BaseY, -BaseZ) public CoordinateSystem3D FlipZ() Returns CoordinateSystem3D Intersect(double, CoordinateSystem3D) return intersect line between two cs xy planes public Line3D? Intersect(double tol, CoordinateSystem3D other) Parameters tol double len tolernace other CoordinateSystem3D other cs Returns Line3D null if cs parallel to the given other IsParallelTo(double, CoordinateSystem3D) states if this cs have Z base parallel to the other given cs public bool IsParallelTo(double tol, CoordinateSystem3D other) Parameters tol double other CoordinateSystem3D Returns bool Move(Vector3D) return another cs with origin translated public CoordinateSystem3D Move(Vector3D delta) Parameters delta Vector3D Returns CoordinateSystem3D Rotate(Line3D, double) return another cs rotated respect given axis public CoordinateSystem3D Rotate(Line3D axis, double angleRad) Parameters axis Line3D angleRad double Returns CoordinateSystem3D Rotate(Vector3D, double) return another cs with same origin and base vector rotated about given vector public CoordinateSystem3D Rotate(Vector3D vectorAxis, double angleRad) Parameters vectorAxis Vector3D angleRad double Returns CoordinateSystem3D RotateAs(double, Vector3D, Vector3D) return another cs rotated as from goes toward to public CoordinateSystem3D RotateAs(double tol, Vector3D from, Vector3D to) Parameters tol double from Vector3D to Vector3D Returns CoordinateSystem3D Simplified() if BaseZ matches one of XY, XZ, YZ default cs then a new cs with origin preserved but baseX, baseY, baseZ overriden will returned. public CoordinateSystem3D Simplified() Returns CoordinateSystem3D ToCadString(double) script to paste in cad to draw cs rgb mode ( x=red, y=green, z=blue ) public string ToCadString(double axisLen) Parameters axisLen double length of x,y,z axes Returns string cad script ToDxfLines(double) retrieve a set of 3 dxf line (RED:x, GREEN:y, BLUE:z) representing CS public IEnumerable<EntityObject> ToDxfLines(double len = 1) Parameters len double Returns IEnumerable<EntityObject> ToDxfUCS(string) public UCS ToDxfUCS(string name) Parameters name string Returns UCS ToString() public override string ToString() Returns string ToString(int) debug string public string ToString(int digits) Parameters digits int Returns string formatted representation of cs origin, x, y, z ToUCS(Vector3D, bool) Transform wcs point to given cs public Vector3D ToUCS(Vector3D p, bool evalCSOrigin = true) Parameters p Vector3D wcs point evalCSOrigin bool if true CS origin will subtracted from wcs point before transform Returns Vector3D ToWCS(Vector3D, bool) transform ucs point to wcs public Vector3D ToWCS(Vector3D p, bool evalCSOrigin = true) Parameters p Vector3D ucs point evalCSOrigin bool if true CS origin will added after transform Returns Vector3D Transform(Matrix4x4) create transformed CS by given transformation matrix public CoordinateSystem3D Transform(Matrix4x4 m) Parameters m Matrix4x4 Returns CoordinateSystem3D"
  },
  "api/SearchAThing.Sci.CoordinateSystem3DAutoEnum.html": {
    "href": "api/SearchAThing.Sci.CoordinateSystem3DAutoEnum.html",
    "title": "Enum CoordinateSystem3DAutoEnum | netcore-sci",
    "keywords": "Enum CoordinateSystem3DAutoEnum Namespace SearchAThing.Sci Assembly netcore-sci.dll public enum CoordinateSystem3DAutoEnum Fields AAA = 0 Arbitrary Axis Alghoritm ( dxf spec ) St7 = 1 Strand7 ( Element Library : Beam Principal Axis System ; Default principal axes of a beam element ) Note: Normal must beam Start to End direction"
  },
  "api/SearchAThing.Sci.DQuaternion.html": {
    "href": "api/SearchAThing.Sci.DQuaternion.html",
    "title": "Class DQuaternion | netcore-sci",
    "keywords": "Class DQuaternion Namespace SearchAThing.Sci Assembly netcore-sci.dll Quaternion implementation using doubles for purpose of Vector3D.RotateAboutAxis and Vector3D.RotateAs references: http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/index.htm https://www.3dgep.com/understanding-quaternions/ http://www.ncsa.illinois.edu/People/kindr/emtc/quaternions/ public class DQuaternion Inheritance object DQuaternion Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks unit test Constructors DQuaternion(Vector3D, double) build quaternion from axis and angle. axis will be subjected to normalization. public DQuaternion(Vector3D axis, double alphaRad) Parameters axis Vector3D alphaRad double DQuaternion(double, Vector3D) direct construct quaternion q=[s, v] public DQuaternion(double s, Vector3D v) Parameters s double v Vector3D Properties Identity Identity qi = [1, nullvector] public static DQuaternion Identity { get; } Property Value DQuaternion v public Vector3D v { get; } Property Value Vector3D Methods Conjugate() Conjugate q* = [s, -v] public DQuaternion Conjugate() Returns DQuaternion Operators operator *(DQuaternion, DQuaternion) Multiply [sa, va] * [sb, vb] = [sa * sb - va * vb, va x vb + sa * vb + sb * va] public static DQuaternion operator *(DQuaternion qa, DQuaternion qb) Parameters qa DQuaternion qb DQuaternion Returns DQuaternion"
  },
  "api/SearchAThing.Sci.DVector3EqualityComparer.html": {
    "href": "api/SearchAThing.Sci.DVector3EqualityComparer.html",
    "title": "Class DVector3EqualityComparer | netcore-sci",
    "keywords": "Class DVector3EqualityComparer Namespace SearchAThing.Sci Assembly netcore-sci.dll helper class to compare vector3d set using given tolerance public class DVector3EqualityComparer : IEqualityComparer<Vector3> Inheritance object DVector3EqualityComparer Implements IEqualityComparer<Vector3> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors DVector3EqualityComparer(double) public DVector3EqualityComparer(double _tol) Parameters _tol double Methods Equals(Vector3, Vector3) public bool Equals(Vector3 a, Vector3 b) Parameters a Vector3 b Vector3 Returns bool GetHashCode(Vector3) public int GetHashCode(Vector3 obj) Parameters obj Vector3 Returns int"
  },
  "api/SearchAThing.Sci.DiscreteSpace-1.html": {
    "href": "api/SearchAThing.Sci.DiscreteSpace-1.html",
    "title": "Class DiscreteSpace<T> | netcore-sci",
    "keywords": "Class DiscreteSpace<T> Namespace SearchAThing.Sci Assembly netcore-sci.dll organize given item list into a discretized space to allow fast query of elements in a space region public class DiscreteSpace<T> Type Parameters T organize given item list into a discretized space to allow fast query of elements in a space region Inheritance object DiscreteSpace<T> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors DiscreteSpace(double, IEnumerable<T>, Func<T, Vector3D>, int) Build discrete space public DiscreteSpace(double _tol, IEnumerable<T> ents, Func<T, Vector3D> entPoint, int _spaceDim) Parameters _tol double length tolerance ents IEnumerable<T> list of entities to discretize entPoint Func<T, Vector3D> function that retrieve relevant point from templated item _spaceDim int search space dimension (2=2D 3=3D) DiscreteSpace(double, IEnumerable<T>, Func<T, IEnumerable<Vector3D>>, int) Build discrete space public DiscreteSpace(double _tol, IEnumerable<T> ents, Func<T, IEnumerable<Vector3D>> entPoints, int _spaceDim) Parameters _tol double length tolerance ents IEnumerable<T> list of entities to discretize entPoints Func<T, IEnumerable<Vector3D>> function that retrieve relevant points from templated item _spaceDim int search space dimension (2=2D 3=3D) Properties Items public IEnumerable<T> Items { get; } Property Value IEnumerable<T> Methods GetItemsAt(Vector3D, double) retrieve items that resides in the space at given point with given extents max distance public IEnumerable<T> GetItemsAt(Vector3D pt, double maxDist) Parameters pt Vector3D point to query elements near maxDist double distance from the given pt to include queried items Returns IEnumerable<T> list of items belonging to sphere centered at pt given radius equals to given maxDist GetItemsAtBySubdiv(Vector3D, BBox3D, int, int) public IEnumerable<T> GetItemsAtBySubdiv(Vector3D pt, BBox3D bbox, int maxRes = 1, int subDivs = 100) Parameters pt Vector3D bbox BBox3D maxRes int subDivs int Returns IEnumerable<T> GetItemsInBBox(BBox3D) public IEnumerable<T> GetItemsInBBox(BBox3D bbox) Parameters bbox BBox3D Returns IEnumerable<T> Search(Vector3D, Vector3D, int) public IEnumerable<T> Search(Vector3D from, Vector3D to, int maxCnt = 10) Parameters from Vector3D to Vector3D maxCnt int Returns IEnumerable<T>"
  },
  "api/SearchAThing.Sci.DiscreteSpaceItem-1.html": {
    "href": "api/SearchAThing.Sci.DiscreteSpaceItem-1.html",
    "title": "Class DiscreteSpaceItem<T> | netcore-sci",
    "keywords": "Class DiscreteSpaceItem<T> Namespace SearchAThing.Sci Assembly netcore-sci.dll base item for DiscreteSpace public class DiscreteSpaceItem<T> Type Parameters T base item for DiscreteSpace Inheritance object DiscreteSpaceItem<T> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors DiscreteSpaceItem(T, Func<T, Vector3D>) public DiscreteSpaceItem(T _Item, Func<T, Vector3D> entPoint) Parameters _Item T entPoint Func<T, Vector3D> DiscreteSpaceItem(T, Func<T, IEnumerable<Vector3D>>) public DiscreteSpaceItem(T _Item, Func<T, IEnumerable<Vector3D>> entPoints) Parameters _Item T entPoints Func<T, IEnumerable<Vector3D>> Properties Item public T? Item { get; } Property Value T Mean public Vector3D Mean { get; } Property Value Vector3D"
  },
  "api/SearchAThing.Sci.DiscreteSpaceItemComparer-1.html": {
    "href": "api/SearchAThing.Sci.DiscreteSpaceItemComparer-1.html",
    "title": "Class DiscreteSpaceItemComparer<T> | netcore-sci",
    "keywords": "Class DiscreteSpaceItemComparer<T> Namespace SearchAThing.Sci Assembly netcore-sci.dll comparer to search in DiscreteSpace public class DiscreteSpaceItemComparer<T> : IComparer<DiscreteSpaceItem<T>> Type Parameters T comparer to search in DiscreteSpace Inheritance object DiscreteSpaceItemComparer<T> Implements IComparer<DiscreteSpaceItem<T>> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors DiscreteSpaceItemComparer(double, int) public DiscreteSpaceItemComparer(double _tol, int _ord) Parameters _tol double _ord int Methods Compare(DiscreteSpaceItem<T>?, DiscreteSpaceItem<T>?) public int Compare(DiscreteSpaceItem<T>? x, DiscreteSpaceItem<T>? y) Parameters x DiscreteSpaceItem<T> y DiscreteSpaceItem<T> Returns int"
  },
  "api/SearchAThing.Sci.DoubleEqualityComparer.html": {
    "href": "api/SearchAThing.Sci.DoubleEqualityComparer.html",
    "title": "Class DoubleEqualityComparer | netcore-sci",
    "keywords": "Class DoubleEqualityComparer Namespace SearchAThing.Sci Assembly netcore-sci.dll helper class to compare a set of doubles by using given tolerance public class DoubleEqualityComparer : IEqualityComparer<double> Inheritance object DoubleEqualityComparer Implements IEqualityComparer<double> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors DoubleEqualityComparer(double) public DoubleEqualityComparer(double _tol) Parameters _tol double Methods Equals(double, double) public bool Equals(double x, double y) Parameters x double y double Returns bool GetHashCode(double) public int GetHashCode(double obj) Parameters obj double Returns int"
  },
  "api/SearchAThing.Sci.Edge.html": {
    "href": "api/SearchAThing.Sci.Edge.html",
    "title": "Class Edge | netcore-sci",
    "keywords": "Class Edge Namespace SearchAThing.Sci Assembly netcore-sci.dll interface implemented by some type of geometries used in Loop such as Line3D, Arc3D and Circle3D public abstract class Edge : Geometry Inheritance object Geometry Edge Derived Arc3D Line3D Inherited Members Geometry.Copy() Geometry.GeomType Geometry.Vertexes Geometry.GeomFrom Geometry.GeomTo Geometry.Length Geometry.MidPoint Geometry.Divide(int, bool) Geometry.Split(double, IEnumerable<Vector3D>) Geometry.Move(Vector3D) Geometry.BBox(double) Geometry.GeomIntersect(double, Geometry, GeomSegmentMode, GeomSegmentMode) Geometry.GeomEquals(double, Geometry, bool) Geometry.DxfEntity object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Edge(GeometryType) protected Edge(GeometryType type) Parameters type GeometryType Properties SGeomFrom GeomFrom (Sense:true) or GeomTo (Sense:false) public Vector3D SGeomFrom { get; } Property Value Vector3D SGeomTo GeomTo (Sense:true) or GeomFrom (Sense:false) public Vector3D SGeomTo { get; } Property Value Vector3D Sense allow to store info about sense; when false SGeomFrom = GeomTo and SGeomTo = GeomFrom public bool Sense { get; protected set; } Property Value bool Methods CheckSense(double, Edge) states if this and/or next given edge need to be toggled in their sense to allow glueing. precedence is given to toggling sense of the next one. returns null if no solution. public (bool needToggleSenseThis, bool needToggleSenseNext)? CheckSense(double tol, Edge nextEdge) Parameters tol double nextEdge Edge Returns (bool needToggleSenseThis, bool needToggleSenseNext)? CopyFrom(Edge) protected void CopyFrom(Edge other) Parameters other Edge EdgeContainsPoint(double, Vector3D) States if edge contains given point on its perimeter public abstract bool EdgeContainsPoint(double tol, Vector3D pt) Parameters tol double pt Vector3D Returns bool EndpointMatches(double, Vector3D) public bool EndpointMatches(double tol, Vector3D endpoint1) Parameters tol double endpoint1 Vector3D Returns bool EndpointMatches(double, Vector3D, Vector3D) public bool EndpointMatches(double tol, Vector3D endpoint1, Vector3D endpoint2) Parameters tol double endpoint1 Vector3D endpoint2 Vector3D Returns bool MoveEnd(double, EdgeEnd, Vector3D) extends edge endpoint toward new given one. returns null if edge can't extends toward new given end. public abstract Edge? MoveEnd(double tol, EdgeEnd end, Vector3D newEnd) Parameters tol double end EdgeEnd newEnd Vector3D Returns Edge Offset(double, Vector3D, double) build offseted version of this edge toward refPt given for the amount specified by offset. public abstract Edge Offset(double tol, Vector3D refPt, double offset) Parameters tol double refPt Vector3D offset double Returns Edge OtherEndpoint(double, Vector3D) public Vector3D OtherEndpoint(double tol, Vector3D endpoint) Parameters tol double endpoint Vector3D Returns Vector3D ProgeCadScript(bool) public abstract string ProgeCadScript(bool final = true) Parameters final bool Returns string Project(double, Plane3D) project this edge to given plane public abstract Edge Project(double tol, Plane3D prjPlane) Parameters tol double prjPlane Plane3D Returns Edge Project(double, Vector3D, bool) project given pt to this edge. public abstract Vector3D? Project(double tol, Vector3D pt, bool segmentMode = true) Parameters tol double pt Vector3D segmentMode bool Returns Vector3D QCadScript(bool) qcad 2d script public abstract string QCadScript(bool final = true) Parameters final bool adds QQ command Returns string ToString(int) public abstract string ToString(int digits) Parameters digits int Returns string ToggleSense() Toggle Sense flag so that SGeomFrom, SGeomTo equals to GeomFrom, GeomTo (Sense:true) or GeomTo, GeomFrom (Sense:false) public Geometry ToggleSense() Returns Geometry"
  },
  "api/SearchAThing.Sci.EdgeEnd.html": {
    "href": "api/SearchAThing.Sci.EdgeEnd.html",
    "title": "Enum EdgeEnd | netcore-sci",
    "keywords": "Enum EdgeEnd Namespace SearchAThing.Sci Assembly netcore-sci.dll public enum EdgeEnd Fields SGeomFrom = 0 SGeomTo = 1"
  },
  "api/SearchAThing.Sci.Ext.HatchSetterDelegate.html": {
    "href": "api/SearchAThing.Sci.Ext.HatchSetterDelegate.html",
    "title": "Delegate Ext.HatchSetterDelegate | netcore-sci",
    "keywords": "Delegate Ext.HatchSetterDelegate Namespace SearchAThing.Sci Assembly netcore-sci.dll public delegate void Ext.HatchSetterDelegate(EntityObject entityObject, bool isBoundary) Parameters entityObject EntityObject isBoundary bool"
  },
  "api/SearchAThing.Sci.Ext.html": {
    "href": "api/SearchAThing.Sci.Ext.html",
    "title": "Class Ext | netcore-sci",
    "keywords": "Class Ext Namespace SearchAThing.Sci Assembly netcore-sci.dll netcore-sci extension methods public static class Ext Inheritance object Ext Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Abs(Vector3) return abs of given Vector3 public static Vector3 Abs(this Vector3 v) Parameters v Vector3 Returns Vector3 AddEntities(DxfObject, IEnumerable<EntityObject>, Layer?) add entity to the given dxf object ( it can be Dxfdocument or Block ) optionally set layer public static void AddEntities(this DxfObject dxfObj, IEnumerable<EntityObject> ents, Layer? layer = null) Parameters dxfObj DxfObject ents IEnumerable<EntityObject> layer Layer AddEntity(DxfObject, EntityObject, Layer?) add entity to the given dxf object ( it can be Dxfdocument or Block ) optionally set layer public static EntityObject AddEntity(this DxfObject dxfObj, EntityObject eo, Layer? layer = null) Parameters dxfObj DxfObject eo EntityObject layer Layer Returns EntityObject Angle(double, double, bool) retrieve angle between from and to given; angles will subjected to normalization [0,2pi) and angle from can be greather than to public static double Angle(this double angleFrom, double angleTo, bool normalizeAngles = true) Parameters angleFrom double angle from angleTo double angle to normalizeAngles bool actuate [0,2PI) angle normalization Returns double AngleInRange(double, double, double, double) states if given angle is contained in from, to angle range; multiturn angles are supported because test will normalize to [0,2pi) automatically. public static bool AngleInRange(this double pt_angle, double angle_from, double angle_to, double radTol = 1E-10) Parameters pt_angle double angle(rad) to test angle_from double angle(rad) from angle_to double angle(rad) to radTol double optional rad tolerance Returns bool AutoIntersect(IEnumerable<Line3D>, double, bool, IEnumerable<Vector3D>?) autointersect given list of segments ( duplicates and overlapping are removed ) TODO: dummy function, optimize public static IReadOnlyList<Line3D> AutoIntersect(this IEnumerable<Line3D> _segs, double tol, bool mergeColinearSegments = true, IEnumerable<Vector3D>? addictionalSplitPoints = null) Parameters _segs IEnumerable<Line3D> tol double mergeColinearSegments bool addictionalSplitPoints IEnumerable<Vector3D> Returns IReadOnlyList<Line3D> AutoTrimExtends(IEnumerable<Edge>, double) automatically trim or extends consecutive edges intersections public static IEnumerable<Edge> AutoTrimExtends(this IEnumerable<Edge> edges, double tol) Parameters edges IEnumerable<Edge> tol double Returns IEnumerable<Edge> AutoZoom(DxfDocument, BBox3D) tries to zoom dxf viewport on the given bbox public static void AutoZoom(this DxfDocument dxf, BBox3D bbox) Parameters dxf DxfDocument bbox BBox3D BBox(IEnumerable<Geometry>, double) bbox that cover all given geometries public static BBox3D BBox(this IEnumerable<Geometry> geometry_block, double tol) Parameters geometry_block IEnumerable<Geometry> tol double length tolerance Returns BBox3D BBox(IEnumerable<Vector3D>) construct a bbox from given enumerable set of points public static BBox3D BBox(this IEnumerable<Vector3D> pts) Parameters pts IEnumerable<Vector3D> points to build bbox Returns BBox3D bbox from given enumerable set of points BBox(IEnumerable<EntityObject>, double) construct a bbox from given set of dxf entity objects public static BBox3D BBox(this IEnumerable<EntityObject> ents, double tol) Parameters ents IEnumerable<EntityObject> enumerable of dxf entity object tol double tolerance for comparision length tests Returns BBox3D new bbox containing given set of dxf entity objects BBox(EntityObject, double) construct a bbox from given dxf EntityObject public static BBox3D BBox(this EntityObject eo, double tol) Parameters eo EntityObject dxf entity object tol double tolerance for comparision length tests Returns BBox3D new bbox that contains given dxf entity object Remarks Currently Text, MText width not evaluated ( only insertion point is considered ). Arc is considered only From, MidPoint, To. Circle is considered only 4 points on circumference. BBox3D(DxfDocument) public static BBox3D BBox3D(this DxfDocument dxf) Parameters dxf DxfDocument Returns BBox3D BestFittingPlane(IEnumerable<Line3D>, double) detect best fitting plane from the set of given lines. precondition: lines must coplanar public static Plane3D BestFittingPlane(this IEnumerable<Line3D> lines, double tol) Parameters lines IEnumerable<Line3D> tol double Returns Plane3D BestFittingPlane(IEnumerable<Vector3D>, double) detect best fitting plane for given set of coplanar points public static Plane3D BestFittingPlane(this IEnumerable<Vector3D> pts, double tol) Parameters pts IEnumerable<Vector3D> tol double Returns Plane3D Boolean(IEnumerable<Vector3D>, double, IEnumerable<Vector3D>, ClipType, bool) can generate a Int64MapExceptionRange exception if double values can't fit into a In64 representation. In that case try with tolerances not too small. It is suggested to use a lenTol/10 to avoid lost of precision during domain conversions. Altenatively use Loop to find exact intersection between planar poly supporting lines and arcs. ( this implementation uses Int64Map and clipper library ) public static IEnumerable<IEnumerable<Vector3D>> Boolean(this IEnumerable<Vector3D> polyA, double tol, IEnumerable<Vector3D> polyB, ClipType type, bool selfCheckInt64MapTolerance = true) Parameters polyA IEnumerable<Vector3D> tol double polyB IEnumerable<Vector3D> type ClipType selfCheckInt64MapTolerance bool Returns IEnumerable<IEnumerable<Vector3D>> CS(EntityObject) public static CoordinateSystem3D CS(this EntityObject eo) Parameters eo EntityObject Returns CoordinateSystem3D CadScript(Face3D) public static string CadScript(this Face3D face) Parameters face Face3D Returns string CadScriptPoint(IEnumerable<Vector3D>) create script that draw a point foreach of point set public static string CadScriptPoint(this IEnumerable<Vector3D> points) Parameters points IEnumerable<Vector3D> points Returns string cadscript CadScriptPolyline(IEnumerable<Vector3D>) create a 3dpolyline cadscript from given set of points public static string CadScriptPolyline(this IEnumerable<Vector3D> points) Parameters points IEnumerable<Vector3D> point set Returns string cad script CheckSense(IEnumerable<Edge>, double) From given set of edges returns the same set eventually toggling sense of edges to make them glue so that SGeomTo of previous equals SGeomFrom of current. It can raise exception if there isn't availability to glue edges regardless toggling their sense. first element will toggled to match second one, then other elements will follow the sense matching established. public static IEnumerable<Edge> CheckSense(this IEnumerable<Edge> edges, double tol) Parameters edges IEnumerable<Edge> input edges list tol double length tolerance Returns IEnumerable<Edge> CheckSort(IEnumerable<Edge>, double) Allow to sort edges when a not consequential set is given to allow subsequent CheckSense. It can raise exception if there isn't a possible sequence continuity between given edges. public static IEnumerable<Edge> CheckSort(this IEnumerable<Edge> edges, double tol) Parameters edges IEnumerable<Edge> input edges list tol double length tolerance Returns IEnumerable<Edge> edges in sequence ( sense not yet checked ) CircleBy3Points(IEnumerable<Vector3D>) build circle3d by given set of 3 points public static Circle3D CircleBy3Points(this IEnumerable<Vector3D> _pts) Parameters _pts IEnumerable<Vector3D> Returns Circle3D Clamp(Vector3, Vector3, Vector3) return clamped Vector3 between [min,max] interval public static Vector3 Clamp(this Vector3 v, Vector3 min, Vector3 max) Parameters v Vector3 xyz vector min Vector3 min value admissible max Vector3 max value admissible Returns Vector3 given vector with xyz components clamped to corresponding min,max components CompareToTol(double, double, double) compare a, b using given tol public static int CompareToTol(this double a, double tol, double b) Parameters a double first term tol double equals tolerance b double second term Returns int -1 if a less than b ; 0 if a equals tol b ; +1 if a greather than b ContainsPoint(IEnumerable<Vector3D>, double, Vector3D, LoopContainsPointMode) states if given point is in polygon public static bool ContainsPoint(this IEnumerable<Vector3D> _pts, double tol, Vector3D pt, LoopContainsPointMode mode = LoopContainsPointMode.InsideOrPerimeter) Parameters _pts IEnumerable<Vector3D> polygon point ( must ordered ) tol double length tolerance pt Vector3D point to test mode LoopContainsPointMode allow to specify contains test type Returns bool ConvexHull2D(IEnumerable<Vector3D>) compute convex hull using LoycCore https://github.com/qwertie/LoycCore public static IEnumerable<Vector3D> ConvexHull2D(this IEnumerable<Vector3D> pts) Parameters pts IEnumerable<Vector3D> Returns IEnumerable<Vector3D> CoordTransform(DxfDocument, Func<Vector3D, Vector3D>) public static IEnumerable<EntityObject> CoordTransform(this DxfDocument dxf, Func<Vector3D, Vector3D> transform) Parameters dxf DxfDocument transform Func<Vector3D, Vector3D> Returns IEnumerable<EntityObject> CoordTransform(EntityObject, Func<Vector3D, Vector3D>, Vector3D?) build a clone of the given entity with coord transformed accordingly given function. public static EntityObject CoordTransform(this EntityObject eo, Func<Vector3D, Vector3D> transform, Vector3D? origin = null) Parameters eo EntityObject transform Func<Vector3D, Vector3D> origin Vector3D Returns EntityObject Debug(Vector3, string) debug to console with optional prefix public static Vector3 Debug(this Vector3 v, string prefix = \"\") Parameters v Vector3 vector prefix string optional prefix Returns Vector3 vector Debug(Vector4, string) debug to console with optional prefix public static Vector4 Debug(this Vector4 v, string prefix = \"\") Parameters v Vector4 vector prefix string optional prefix Returns Vector4 vector Decompose(Matrix4x4) decompose given 4x4 matrix into scale, rotation, translation public static (Vector3 translation, Quaternion rotation, Vector3 scale, bool success) Decompose(this Matrix4x4 m) Parameters m Matrix4x4 Returns (Vector3 translation, Quaternion rotation, Vector3 scale, bool success) DetectPlane(IEnumerable<Edge>, double) public static Plane3D DetectPlane(this IEnumerable<Edge> edges, double tol) Parameters edges IEnumerable<Edge> tol double Returns Plane3D DistinctKeepOrder(IEnumerable<Vector3D>, Vector3DEqualityComparer) retrieve distinct of given vector set ensuring to maintain given order public static IEnumerable<Vector3D> DistinctKeepOrder(this IEnumerable<Vector3D> vectors, Vector3DEqualityComparer cmp) Parameters vectors IEnumerable<Vector3D> cmp Vector3DEqualityComparer Returns IEnumerable<Vector3D> DrawCube(DxfObject, Vector3D, double, Layer?) Creates and add dxf entities for a 6 faces of a cube public static IEnumerable<EntityObject> DrawCube(this DxfObject dxfObj, Vector3D center, double L, Layer? layer = null) Parameters dxfObj DxfObject center Vector3D L double layer Layer Returns IEnumerable<EntityObject> DrawCuboid(DxfObject, Vector3D, Vector3D, Layer?) Creates and add dxf entities for 6 faces of a cuboid public static IEnumerable<EntityObject> DrawCuboid(this DxfObject dxfObj, Vector3D center, Vector3D size, Layer? layer = null) Parameters dxfObj DxfObject center Vector3D size Vector3D layer Layer Returns IEnumerable<EntityObject> DrawStar(DxfObject, Vector3D, double, Layer?) Creates and add dxf entities for a 3 axis of given length centered in given center point. public static IEnumerable<EntityObject> DrawStar(this DxfObject dxfObj, Vector3D center, double L, Layer? layer = null) Parameters dxfObj DxfObject center Vector3D L double layer Layer Returns IEnumerable<EntityObject> DrawTimeline(DxfObject, List<(DateTime from, DateTime to)>, double, double, double, double, Func<DateTime, string>?) public static IEnumerable<EntityObject> DrawTimeline(this DxfObject dxf, List<(DateTime from, DateTime to)> timeline, double textHeight = 2, double circleRadius = 1.5, double maxWidth = 180, double stopDays = 60, Func<DateTime, string>? dtStr = null) Parameters dxf DxfObject timeline List<(DateTime from, DateTime to)> textHeight double circleRadius double maxWidth double stopDays double dtStr Func<DateTime, string> Returns IEnumerable<EntityObject> Entities(DxfDocument) public static IEnumerable<EntityObject> Entities(this DxfDocument dxf) Parameters dxf DxfDocument Returns IEnumerable<EntityObject> EqualsTol(IEnumerable<Vector3D>, double, IEnumerable<Vector3D>) checks two list of vectors are equals and with same order of elements public static bool EqualsTol(this IEnumerable<Vector3D> lst, double tol, IEnumerable<Vector3D> other) Parameters lst IEnumerable<Vector3D> tol double other IEnumerable<Vector3D> Returns bool EqualsTol(IEnumerable<(double, double)>, IEnumerable<(double, double)>, double, double) compares two list tuples public static bool EqualsTol(this IEnumerable<(double, double)> tuple_list1, IEnumerable<(double, double)> tuple_list2, double tol1, double tol2) Parameters tuple_list1 IEnumerable<(double, double)> tuple_list2 IEnumerable<(double, double)> tol1 double tol2 double Returns bool EqualsTol(Vector3, double, Vector3) public static bool EqualsTol(this Vector3 v, double tol, Vector3 other) Parameters v Vector3 tol double other Vector3 Returns bool EqualsTol(Vector3, double, Vector3) public static bool EqualsTol(this Vector3 v, double tol, Vector3 other) Parameters v Vector3 tol double other Vector3 Returns bool Explode(Insert) public static IEnumerable<EntityObject> Explode(this Insert ins) Parameters ins Insert Returns IEnumerable<EntityObject> Fmt(double, int, int) format number with given decimals and total length aligning right public static string Fmt(this double n, int dec, int size) Parameters n double number to format dec int decimals round size int string size Returns string string representing given number formatted with given decimals and total length aligning right Fmt(Matrix4x4, int, int) matrix4x4 formatted print suitable for monospace font or terminal display public static string Fmt(this Matrix4x4 m, int dec, int width = 10) Parameters m Matrix4x4 matrix dec int decimal to display width int column width Returns string formatted text representation of given matrix Fmt(float, int, int) format number with given decimals and total length aligning right public static string Fmt(this float n, int dec, int size) Parameters n float number to format dec int decimals round size int string size Returns string string representing given number formatted with given decimals and total length aligning right GetItem(Matrix4x4, int, int) retrieve item at given row(0..3), col(0..3) of the matrix4x4 public static float GetItem(this Matrix4x4 m, int rowIdx, int colIdx) Parameters m Matrix4x4 matrix rowIdx int row (0 based index) colIdx int col (0 based index) Returns float matrix item Intersect(IEnumerable<Geometry>, double, IEnumerable<Geometry>, GeomSegmentMode, GeomSegmentMode) find intersection geometries resulting from all this geometries with all given geom2 public static IEnumerable<(Geometry intersectGeom, Geometry g1, Geometry g2)> Intersect(this IEnumerable<Geometry> _geom1, double tol, IEnumerable<Geometry> _geom2, GeomSegmentMode geom1SegmentMode = GeomSegmentMode.FromTo, GeomSegmentMode geom2SegmentMode = GeomSegmentMode.FromTo) Parameters _geom1 IEnumerable<Geometry> tol double length tolerance _geom2 IEnumerable<Geometry> geom1SegmentMode GeomSegmentMode if geom1 item is Line3D specifies how to consider it geom2SegmentMode GeomSegmentMode if geom2 item is Line3D specifies how to consider it Returns IEnumerable<(Geometry intersectGeom, Geometry g1, Geometry g2)> Intersect(IEnumerable<Line3D>, double, Line3D, GeomSegmentMode) Find intersection points (0,1,2) of the given line with the given polygon TODO unit test public static IEnumerable<Vector3D> Intersect(this IEnumerable<Line3D> polygonSegments, double tol, Line3D line, GeomSegmentMode segmentMode) Parameters polygonSegments IEnumerable<Line3D> tol double line Line3D segmentMode GeomSegmentMode Returns IEnumerable<Vector3D> Inverse(Matrix4x4) retrieve inverse of given matrix public static Matrix4x4 Inverse(this Matrix4x4 m) Parameters m Matrix4x4 4x4 matrix Returns Matrix4x4 inverse of given matrix Remarks can gen exception IsAClosedPoly(IEnumerable<Line3D>, double) Preprocess segs with SortPoly if needed. Return the ordered segments poly or null if not a closed poly. public static IEnumerable<Line3D>? IsAClosedPoly(this IEnumerable<Line3D> segs, double tol) Parameters segs IEnumerable<Line3D> tol double Returns IEnumerable<Line3D> IsLinearIndependent(IEnumerable<Vector3D>) states if given 3 vectors are linearly independent public static bool IsLinearIndependent(this IEnumerable<Vector3D> vectors) Parameters vectors IEnumerable<Vector3D> Returns bool true if given vector are linearly independent Remarks unit test Length(IEnumerable<Vector3D>) compute length of polyline from given seq_pts public static double Length(this IEnumerable<Vector3D> seq_pts) Parameters seq_pts IEnumerable<Vector3D> Returns double MakeVertexToEdges(IEnumerable<Edge>, double) public static Dictionary<Vector3D, List<Edge>> MakeVertexToEdges(this IEnumerable<Edge> edges, double tol) Parameters edges IEnumerable<Edge> tol double Returns Dictionary<Vector3D, List<Edge>> Mean(IEnumerable<Vector3D>, bool) mean of given vetor3d list note: if used to compute poly center enable skipFirstAtEnd public static Vector3D Mean(this IEnumerable<Vector3D> lst, bool skipFirstAtEnd = false) Parameters lst IEnumerable<Vector3D> skipFirstAtEnd bool Returns Vector3D MergeColinearSegments(IEnumerable<Line3D>, double) merge colinear overlapped segments into single result segments direction and order is not ensured pre: segs must colinear public static IEnumerable<Line3D> MergeColinearSegments(this IEnumerable<Line3D> _segs, double tol) Parameters _segs IEnumerable<Line3D> tol double Returns IEnumerable<Line3D> MidPoint(Polyline2D) get the midpoint of the 3d polyline distance is computed over all segments public static Vector3D? MidPoint(this Polyline2D poly) Parameters poly Polyline2D Returns Vector3D MinDistance(IEnumerable<double>) Return the min distance between two adiacent number given from all of the given ordered set of numbers. public static double MinDistance(this IEnumerable<double> orderedNumbers) Parameters orderedNumbers IEnumerable<double> Returns double 0 if empty set or 1 element. min distance otherwise. MinMax(IEnumerable<double>) retrieve min,max w/single sweep public static (double min, double max) MinMax(this IEnumerable<double> input) Parameters input IEnumerable<double> Returns (double min, double max) ModelSpace(DxfDocument) public static Block ModelSpace(this DxfDocument dxf) Parameters dxf DxfDocument Returns Block NormalizeAngle(double, double, double) Normalize given angle(rad) into [maxRad-2PI,maxRad) range. public static double NormalizeAngle(this double angle_rad, double maxRadExcluded = 6.283185307179586, double radTol = 1E-10) Parameters angle_rad double angle(rad) to normalize maxRadExcluded double normalization range (excluded) max value ( minimum will computed as max-2PI ) radTol double override rad tolerance Returns double angle normalized Remarks unit test Normalized(Vector3) normalize given vector public static Vector3 Normalized(this Vector3 v) Parameters v Vector3 vector Returns Vector3 normalized vector Normalized(Vector4) public static Vector4 Normalized(this Vector4 v) Parameters v Vector4 Returns Vector4 Offset(IEnumerable<Vector3D>, double, double) increase of decrease polygon points offseting ( this implementation uses Int64Map and clipper library ) public static IEnumerable<Vector3D> Offset(this IEnumerable<Vector3D> pts, double tol, double offset) Parameters pts IEnumerable<Vector3D> tol double offset double Returns IEnumerable<Vector3D> Offset(Polyline2D, double, Vector3D, double) public static Polyline2D Offset(this Polyline2D lwp, double tol, Vector3D sideRefPt, double amount) Parameters lwp Polyline2D tol double sideRefPt Vector3D amount double Returns Polyline2D OffsetGeoms(Polyline2D, double, Vector3D, double) create offseted polygon from this one by offset of given offset amount toward given sideRefPt. public static IEnumerable<Edge> OffsetGeoms(this Polyline2D lwp, double tol, Vector3D sideRefPt, double offset) Parameters lwp Polyline2D this polyline tol double length tolerance sideRefPt Vector3D offseted polygon will the one on the side nearest to this ref pt. The offseted polygon doesn't need to contains this point, its only used to disambiguate the side choose. offset double offset amount from this actual polyline toward offseted one. Returns IEnumerable<Edge> offseted polygon Points(EntityObject) public static IEnumerable<Vector3D> Points(this EntityObject eo) Parameters eo EntityObject Returns IEnumerable<Vector3D> PolyPoints(IEnumerable<Line3D>) retrieve s[0].from, s[1].from, ... s[n-1].from, s[n-1].to points public static IEnumerable<Vector3D> PolyPoints(this IEnumerable<Line3D> segs) Parameters segs IEnumerable<Line3D> Returns IEnumerable<Vector3D> PolyPoints(IEnumerable<Vector3D>, double, bool) given a set of polygon pts, returns the enumeation of all pts so that the last not attach to the first ( if makeClosed = false ). Elsewhere it returns a last point equals the first ( makeClosed = true ). public static IEnumerable<Vector3D> PolyPoints(this IEnumerable<Vector3D> pts, double tol, bool makeClosed = false) Parameters pts IEnumerable<Vector3D> tol double makeClosed bool Returns IEnumerable<Vector3D> PolygonSegments(IEnumerable<Vector3D>, double) yields an ienumerable of polygon segments corresponding to the given polygon pts ( z is not considered ) works even last point not equals the first one public static IEnumerable<Line3D> PolygonSegments(this IEnumerable<Vector3D> pts, double tol) Parameters pts IEnumerable<Vector3D> tol double Returns IEnumerable<Line3D> QCadScript(IEnumerable<Edge>, bool) qcad script from edge enumerable public static string QCadScript(this IEnumerable<Edge> edges, bool final = true) Parameters edges IEnumerable<Edge> final bool if true adds QQ Returns string QCadScript(IEnumerable<Geometry>) qcad script from geoms public static string QCadScript(this IEnumerable<Geometry> geoms) Parameters geoms IEnumerable<Geometry> Returns string QCadScript(Polyline2D, double) qcad script from lwp public static string QCadScript(this Polyline2D lwp, double tol) Parameters lwp Polyline2D tol double Returns string RadTol(double, double) compute angle rad tolerance by given arc length tolerance as (lenTol / radius) public static double RadTol(this double lenTol, double radius) Parameters lenTol double length tolerance on the arc radius double radius of the arc Returns double RepeatFirstAtEnd(IEnumerable<Vector3D>, double) given points a,b,c it will return a,b,c,a ( first is repeated at end ) it avoid to repeat first at end when latest point already equals the first one public static IEnumerable<Vector3D> RepeatFirstAtEnd(this IEnumerable<Vector3D> pts, double tol) Parameters pts IEnumerable<Vector3D> tol double Returns IEnumerable<Vector3D> Reversed(IEnumerable<Vector3D>) retrieve reversed version of given point set ( used to convert ccw, cw ) public static IList<Vector3D> Reversed(this IEnumerable<Vector3D> pts) Parameters pts IEnumerable<Vector3D> Returns IList<Vector3D> Reversed(IList<Vector3D>) retrieve reversed version of given point set ( used to convert ccw, cw ) public static IEnumerable<Vector3D> Reversed(this IList<Vector3D> pts) Parameters pts IList<Vector3D> Returns IEnumerable<Vector3D> Segments(IEnumerable<Geometry>, double) segments representation of given geometries if arc found a segment between endpoints returns public static IEnumerable<Line3D> Segments(this IEnumerable<Geometry> geometry_block, double tol) Parameters geometry_block IEnumerable<Geometry> tol double length tolerance Returns IEnumerable<Line3D> Set(Hatch, HatchSetterDelegate) set hatch and boundary entities with given action public static Hatch Set(this Hatch hatch, Ext.HatchSetterDelegate setter) Parameters hatch Hatch setter Ext.HatchSetterDelegate Returns Hatch SetColor(EntityObject, AciColor) public static EntityObject SetColor(this EntityObject eo, AciColor color) Parameters eo EntityObject color AciColor Returns EntityObject SetLayer(IEnumerable<EntityObject>, Layer) Set layer of given set of dxf entities public static IEnumerable<EntityObject> SetLayer(this IEnumerable<EntityObject> ents, Layer layer) Parameters ents IEnumerable<EntityObject> layer Layer Returns IEnumerable<EntityObject> SetLayer(EntityObject, Layer) public static EntityObject SetLayer(this EntityObject eo, Layer layer) Parameters eo EntityObject layer Layer Returns EntityObject SetX(Vector3, float) create new Vector3 with given x overriden, others yz unchanged public static Vector3 SetX(this Vector3 v, float x) Parameters v Vector3 vector x float x value to set Returns Vector3 changed vector SetY(Vector3, float) create new Vector3 with given y overriden, others xz unchanged public static Vector3 SetY(this Vector3 v, float y) Parameters v Vector3 vector y float y value to set Returns Vector3 changed vector SetZ(Vector3, float) create new Vector3 with given z overriden, others xy unchanged public static Vector3 SetZ(this Vector3 v, float z) Parameters v Vector3 vector z float z value to set Returns Vector3 changed vector Similarity(double, double) Test two numbers for similarity; the factor of similarity f = (max(x,y)-min(x,y)) / min(abs(x), abs(y)). Special cases: if x=y=0 returns 0 if x=0 xor y=0 returns max(abs(x),abs(y)))/2 if sign(x) != sign(y) returns StDevP(x,y) public static double Similarity(this double x, double y) Parameters x double first number y double second number Returns double similarity factor SortCCW(IEnumerable<Vector3D>, double, CoordinateSystem3D) sort the set of points in ccw order; note that first returned point could not match the first point in the sequence ( for that use RouteFirst() ext ) public static IEnumerable<Vector3D> SortCCW(this IEnumerable<Vector3D> pts, double tol, CoordinateSystem3D cs) Parameters pts IEnumerable<Vector3D> points tol double length tolerance cs CoordinateSystem3D CS used with origin as rotation center to sort ccw points and BaseZ used as reference rotation axis ( points plane normal right-hand rotate around ) Returns IEnumerable<Vector3D> input set of points ccw sorted SortCCW(IEnumerable<Vector3D>, double, Vector3D, Vector3D) sort the set of points in ccw order; note that first returned point could not match the first point in the sequence ( for that use RouteFirst() ext ) public static IEnumerable<Vector3D> SortCCW(this IEnumerable<Vector3D> pts, double tol, Vector3D center, Vector3D refAxis) Parameters pts IEnumerable<Vector3D> points tol double length tolerance center Vector3D rotation center to sort ccw points ( can use Mean() or Centroid() ext for closed polygon ) refAxis Vector3D reference rotation axis ( points plane normal right-hand rotate around ) Returns IEnumerable<Vector3D> input set of points ccw sorted SortCCW<T>(IEnumerable<T>, double, Func<T, Vector3D>, CoordinateSystem3D) sort the set of templated points in ccw order; note that first returned point could not match the first point in the sequence ( for that use RouteFirst() ext ) public static IEnumerable<T> SortCCW<T>(this IEnumerable<T> _tpts, double tol, Func<T, Vector3D> getPoint, CoordinateSystem3D cs) Parameters _tpts IEnumerable<T> templated points tol double length tolerance getPoint Func<T, Vector3D> function to extract Vector3D point from templated point cs CoordinateSystem3D CS used with origin as rotation center to sort ccw points and BaseZ used as reference rotation axis ( points plane normal right-hand rotate around ) Returns IEnumerable<T> input set of templated points ccw sorted Type Parameters T SortCCW<T>(IEnumerable<T>, double, Func<T, Vector3D>, Vector3D, Vector3D) sort the set of templated points in ccw order; note that first returned point could not match the first point in the sequence ( for that use RouteFirst() ext ) public static IEnumerable<T> SortCCW<T>(this IEnumerable<T> tpts, double tol, Func<T, Vector3D> getPoint, Vector3D center, Vector3D refAxis) Parameters tpts IEnumerable<T> templated points tol double length tolerance getPoint Func<T, Vector3D> function to extract Vector3D point from templated point center Vector3D rotation center to sort ccw points ( can use Mean() or Centroid() ext for closed polygon ) refAxis Vector3D reference rotation axis ( points plane normal right-hand rotate around ) Returns IEnumerable<T> input set of templated points ccw sorted Type Parameters T Sqrt(Vector3D) compute (Sqrt(v.x), Sqrt(v.y), Sqrt(v.z)) public static Vector3D Sqrt(this Vector3D v) Parameters v Vector3D input vector Returns Vector3D sqrt(v) StatNfos(IEnumerable<double>) Compute some stat info about given number set using LinqStatistics public static NumbersStatNfo StatNfos(this IEnumerable<double> numbers) Parameters numbers IEnumerable<double> Returns NumbersStatNfo a tuple containing stat informations about given number set StringRepresentation(IEnumerable<Vector3D>) array invariant string vector3d representation \"(x1,y1,z2);(x2,y2,z2)\"; an array of Vector3D can be rebuilt from string using Vector3D.FromStringArray public static string StringRepresentation(this IEnumerable<Vector3D> pts) Parameters pts IEnumerable<Vector3D> Returns string Sum(IEnumerable<Vector3D>) retrieve the sum of given vector list public static Vector3D Sum(this IEnumerable<Vector3D> lst) Parameters lst IEnumerable<Vector3D> vector list Returns Vector3D sum of given vector list TakeUntilAdjacent(IEnumerable<Line3D>, double, bool) Return the input set of segments until an adjacency between one and next is found. It can rectify the versus of line (by default) if needed. Note: returned set references can be different if rectifyVersus==true public static IEnumerable<Line3D> TakeUntilAdjacent(this IEnumerable<Line3D> segs, double tol, bool rectifyVersus = true) Parameters segs IEnumerable<Line3D> tol double rectifyVersus bool Returns IEnumerable<Line3D> Tessellate(IEnumerable<Vector3D>) tessellate given pts list using 1 contour in clockwise ordering see used tessellation library ( https://github.com/speps/LibTessDotNet ) public static IEnumerable<Triangle3D> Tessellate(this IEnumerable<Vector3D> _pts) Parameters _pts IEnumerable<Vector3D> pts to tessellate in triangles Returns IEnumerable<Triangle3D> list of triangles Thin(IEnumerable<double>, double, bool, bool) retrieve given input set ordered with only distinct values after comparing through tolerance in this case result set contains only values from the input set (default) or rounding to given tol if maintain_original_values is false; if keep_ends true (default) min and max already exists at begin/end of returned sequence public static List<double> Thin(this IEnumerable<double> input, double tol, bool keep_ends = true, bool maintain_original_values = true) Parameters input IEnumerable<double> tol double keep_ends bool maintain_original_values bool Returns List<double> ToArc3D(Arc, Vector3D?, double) construct arc3 from given dxf arc public static Arc3D ToArc3D(this Arc dxf_arc, Vector3D? start_vertex = null, double start_vertex_tol = 0) Parameters dxf_arc Arc start_vertex Vector3D optional start vertex allow to inject edge sense (used when explode from lwpolyline) start_vertex_tol double when use start_vertex argument this is the tol for equality test Returns Arc3D ToCSV(IEnumerable<object>) exports to a csv string some known fields note: not really a csv its a tab separated values for debug purpose just copy and paste public static string ToCSV(this IEnumerable<object> lst) Parameters lst IEnumerable<object> Returns string ToCadScript(IEnumerable<Line3D>) public static string ToCadScript(this IEnumerable<Line3D> lines) Parameters lines IEnumerable<Line3D> Returns string ToCircle3D(Circle) build circle3d by provided dxf circle public static Circle3D ToCircle3D(this Circle dxf_circle) Parameters dxf_circle Circle Returns Circle3D ToCoordSequence(IEnumerable<Vector3D>) from a list of vector3d retrieve x1,y1,z1,x2,y2,z2,... coord sequence public static IEnumerable<double> ToCoordSequence(this IEnumerable<Vector3D> pts) Parameters pts IEnumerable<Vector3D> Returns IEnumerable<double> ToCoordString2D(IEnumerable<Vector3D>) produce a string with x1,y1,x2,y2, ... public static string ToCoordString2D(this IEnumerable<Vector3D> points) Parameters points IEnumerable<Vector3D> Returns string ToCoordString3D(IEnumerable<Vector3D>) produce a string with x1,y1,z1,x2,y2,z2, ... public static string ToCoordString3D(this IEnumerable<Vector3D> points) Parameters points IEnumerable<Vector3D> Returns string ToDVector3(Vector3) convert System.Numerics.Vector3 to netdxf.Vector3 public static Vector3 ToDVector3(this Vector3 v) Parameters v Vector3 Returns Vector3 ToDeg(Vector3) convert given vector to degrees public static Vector3 ToDeg(this Vector3 v) Parameters v Vector3 vector source ( radians ) Returns Vector3 vector ( degrees ) ToDxfLine(Line3D) public static Line ToDxfLine(this Line3D line) Parameters line Line3D Returns Line ToEulerAngles(Matrix4x4) extract xyz rotation angles from given rotation matrix. Reference: Extracting Euler Angles from a Rotation Matrix by Mike Day public static Vector3 ToEulerAngles(this Matrix4x4 rotation) Parameters rotation Matrix4x4 rotation matrix Returns Vector3 Vector3 with rotation angles(rad) around wcs xyz axes Remarks unit test ToFace(Loop) build face with given outer loop public static Face ToFace(this Loop loop) Parameters loop Loop Returns Face ToFace(IEnumerable<Polyline2D>, double) build planar face with given loops ( first is the outer ); input loop can be unordered ( loop with greather area will be considered as outer loop ); precondition: loops must lie on same plane public static Face ToFace(this IEnumerable<Polyline2D> lwpolyline, double tol) Parameters lwpolyline IEnumerable<Polyline2D> tol double Returns Face ToGeometries(Polyline2D, double) extracs Arc3D, Line3D from given lwpolyline public static IEnumerable<Geometry> ToGeometries(this Polyline2D lwpolyline, double tol) Parameters lwpolyline Polyline2D tol double length tolerance Returns IEnumerable<Geometry> ToHatch(IEnumerable<Geometry>, HatchPattern, bool) public static Hatch ToHatch(this IEnumerable<Geometry> _geom, HatchPattern pattern, bool associative = true) Parameters _geom IEnumerable<Geometry> pattern HatchPattern associative bool Returns Hatch ToHatch(Polyline2D, HatchPattern, bool) public static Hatch ToHatch(this Polyline2D lw, HatchPattern pattern, bool associative = true) Parameters lw Polyline2D pattern HatchPattern associative bool Returns Hatch ToLine3D(Line) public static Line3D ToLine3D(this Line line) Parameters line Line Returns Line3D ToLoop(Polyline2D, double) public static Loop ToLoop(this Polyline2D lwpolyline, double tol) Parameters lwpolyline Polyline2D tol double Returns Loop ToLwPolyline(IEnumerable<Geometry>, double, CoordinateSystem3D, bool) build 2d dxf polyline. precondition: geom vertex must lie on the same plane note: use RepeatFirstAtEnd extension to build a closed polyline public static Polyline2D ToLwPolyline(this IEnumerable<Geometry> _geom, double tol, CoordinateSystem3D cs, bool closed) Parameters _geom IEnumerable<Geometry> tol double length tolerance cs CoordinateSystem3D lw CS closed bool Returns Polyline2D ToNVector3(Vector3) convert netdxf.Vector3 to System.Numerics.Vector3 ( double cast to float ) public static Vector3 ToNVector3(this Vector3 v) Parameters v Vector3 Returns Vector3 ToPlane(Polyline2D) public static Plane3D ToPlane(this Polyline2D lwpolyline) Parameters lwpolyline Polyline2D Returns Plane3D ToPolyline(IEnumerable<Vector3D>, bool) build 3d dxf polyline note: use RepeatFirstAtEnd extension to build a closed polyline public static Polyline3D ToPolyline(this IEnumerable<Vector3D> pts, bool isClosed = true) Parameters pts IEnumerable<Vector3D> isClosed bool Returns Polyline3D ToRad(Vector3) convert given vector to radians public static Vector3 ToRad(this Vector3 v) Parameters v Vector3 vector source ( degrees ) Returns Vector3 vector ( radians ) ToTriangle3D(IEnumerable<Vector3D>) public static Triangle3D ToTriangle3D(this IEnumerable<Vector3D> pts) Parameters pts IEnumerable<Vector3D> Returns Triangle3D ToVector2(Vector4) create vector2 from vector4 discarding z, w public static Vector2 ToVector2(this Vector4 v) Parameters v Vector4 vector4 input Returns Vector2 vector2 ToVector3(Vector4) create vector3 from vector4 discarding w public static Vector3 ToVector3(this Vector4 v) Parameters v Vector4 vector4 input Returns Vector3 vector3 ToVector3D(Vector3) convert given vector3 to vector3d public static Vector3D ToVector3D(this Vector3 v) Parameters v Vector3 vector3 Returns Vector3D vector3d ToVector3D(Vector4) convert given Vector4 to Vector3D ( discarding w ) public static Vector3D ToVector3D(this Vector4 v) Parameters v Vector4 Vector4 Returns Vector3D Vector3D Transform(Vector3, Matrix4x4) public static Vector3 Transform(this Vector3 v, Matrix4x4 m) Parameters v Vector3 m Matrix4x4 Returns Vector3 Transform(Vector4, Matrix4x4) public static Vector4 Transform(this Vector4 v, Matrix4x4 m) Parameters v Vector4 m Matrix4x4 Returns Vector4 Union(IEnumerable<BBox3D>) union of bboxes public static BBox3D Union(this IEnumerable<BBox3D> bboxes) Parameters bboxes IEnumerable<BBox3D> Returns BBox3D Vector3DCoords(Polyline2D) enumerate as Vector3D given dxf lwpolyline vertexes public static IEnumerable<Vector3D> Vector3DCoords(this Polyline2D lwp) Parameters lwp Polyline2D Returns IEnumerable<Vector3D> Vector3DCoords(Polyline3D) enumerate as Vector3D given dxf polyline vertexes public static IEnumerable<Vector3D> Vector3DCoords(this Polyline3D pl) Parameters pl Polyline3D Returns IEnumerable<Vector3D> Vertexes(IEnumerable<Geometry>, double) vertexes from given set of geometries public static IEnumerable<Vector3D> Vertexes(this IEnumerable<Geometry> _geometry_block, double tol) Parameters _geometry_block IEnumerable<Geometry> tol double length tolerance Returns IEnumerable<Vector3D> WeightedDistribution(IEnumerable<double>, int) retrieve a list of N pairs (value,presence) with value between min and max of inputs and presence between 0..1 that represents the percent of presence of the value examples: inputs = ( 1, 2, 3 ), N = 3 results: ( (1, .33), (2, .33), (3, .33) ) inputs = ( 1, 2.49, 3), N = 3 results: ( (1, .33), (2, .169), (3, .497) ) inputs = ( 1, 2, 3), N = 4 results: ( (1, .33), (1.6, .16), (2.3, .16), (3, .33) ) public static (double off, double weight)[] WeightedDistribution(this IEnumerable<double> inputs, int N) Parameters inputs IEnumerable<double> N int Returns (double off, double weight)[] XYArea(IEnumerable<Vector3D>, double) (abs) Area of a polygon (does not consider z). note: points must ccw ordered. https://en.wikipedia.org/wiki/Centroid public static double XYArea(this IEnumerable<Vector3D> pts, double tol) Parameters pts IEnumerable<Vector3D> tol double Returns double XYCentroid(IEnumerable<Vector3D>, double) Centroid of a polygon (does not consider z). note: points must ccw ordered. use overloaded method if signed area already computed. https://en.wikipedia.org/wiki/Centroid public static Vector3D XYCentroid(this IEnumerable<Vector3D> pts, double tol) Parameters pts IEnumerable<Vector3D> tol double Returns Vector3D XYCentroid(IEnumerable<Vector3D>, double, double) Centroid of a polygon (does not consider z). note: points must ccw ordered. https://en.wikipedia.org/wiki/Centroid public static Vector3D XYCentroid(this IEnumerable<Vector3D> _pts, double tol, double signed_area) Parameters _pts IEnumerable<Vector3D> tol double signed_area double Returns Vector3D XYClosedPolys(IEnumerable<Line3D>, double, int) build polygons from given list of 2d segments by intersecting segments. (does not consider z) public static IEnumerable<IReadOnlyList<Vector3D>> XYClosedPolys(this IEnumerable<Line3D> segs, double tol, int polyMaxPoints = 0) Parameters segs IEnumerable<Line3D> tol double polyMaxPoints int Returns IEnumerable<IReadOnlyList<Vector3D>> XYSignedArea(IEnumerable<Vector3D>, double) (signed) Area of a polygon (does not consider z); note: points must ccw ordered. https://en.wikipedia.org/wiki/Centroid public static double XYSignedArea(this IEnumerable<Vector3D> _pts, double tol) Parameters _pts IEnumerable<Vector3D> tol double Returns double ZapDuplicates(IEnumerable<Vector3D>, Vector3DEqualityComparer) return pts (maintaining order) w/out duplicates public static IEnumerable<Vector3D> ZapDuplicates(this IEnumerable<Vector3D> pts, Vector3DEqualityComparer cmp) Parameters pts IEnumerable<Vector3D> cmp Vector3DEqualityComparer Returns IEnumerable<Vector3D> ZapDuplicates(IEnumerable<Vector3D>, double) return pts (maintaining order) w/out duplicates use the other overloaded method if already have a vector 3d equality comparer public static IEnumerable<Vector3D> ZapDuplicates(this IEnumerable<Vector3D> pts, double tol) Parameters pts IEnumerable<Vector3D> tol double Returns IEnumerable<Vector3D>"
  },
  "api/SearchAThing.Sci.Face.BooleanMode.html": {
    "href": "api/SearchAThing.Sci.Face.BooleanMode.html",
    "title": "Enum Face.BooleanMode | netcore-sci",
    "keywords": "Enum Face.BooleanMode Namespace SearchAThing.Sci Assembly netcore-sci.dll public enum Face.BooleanMode Fields Difference = 2 Intersect = 1 Union = 0"
  },
  "api/SearchAThing.Sci.Face.html": {
    "href": "api/SearchAThing.Sci.Face.html",
    "title": "Class Face | netcore-sci",
    "keywords": "Class Face Namespace SearchAThing.Sci Assembly netcore-sci.dll Planar face with one (outer) or more loops (inners) public class Face Inheritance object Face Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors Face(Loop) build a face with given outer loop public Face(Loop loop) Parameters loop Loop Face(Plane3D, IEnumerable<Loop>) planar face with outer and optional inner loops public Face(Plane3D plane, IEnumerable<Loop> loops) Parameters plane Plane3D plane where loop lies loops IEnumerable<Loop> loops ( first is the outer ) Properties Area (cached) area of face ( outer loop area - inner loops area ) public double Area { get; } Property Value double Loops public IReadOnlyList<Loop> Loops { get; } Property Value IReadOnlyList<Loop> Plane public Plane3D Plane { get; } Property Value Plane3D Methods Boolean(double, Face, BooleanMode, DxfDocument?) boolean operation with this and other loops. precondition: must coplanar public IEnumerable<Face> Boolean(double tol, Face other, Face.BooleanMode mode = BooleanMode.Intersect, DxfDocument? debugDxf = null) Parameters tol double other Face mode Face.BooleanMode debugDxf DxfDocument Returns IEnumerable<Face> Contains(double, Edge, bool, LoopContainsEdgeMode) states if given edge is contained into this face public bool Contains(double tol, Edge edge, bool evalOnlyOuter, LoopContainsEdgeMode mode = LoopContainsEdgeMode.InsideExcludedPerimeter) Parameters tol double length tolerance edge Edge edge to test evalOnlyOuter bool if true and edge is contained into and inner the test returns false mode LoopContainsEdgeMode type of contains test Returns bool DxfEntities(double) public IEnumerable<Polyline2D> DxfEntities(double tol) Parameters tol double Returns IEnumerable<Polyline2D> Move(Vector3D) return new face translated of given delta public Face Move(Vector3D delta) Parameters delta Vector3D Returns Face Overlap(double, Edge) test if edge overlap any of loop edges of this face public bool Overlap(double tol, Edge edge) Parameters tol double edge Edge Returns bool Project(double, Plane3D) project this face edges to the given projection plane public Face Project(double tol, Plane3D prjPlane) Parameters tol double prjPlane Plane3D Returns Face RotateAs(double, Vector3D, Vector3D) rotate cs and edges like point from rotate toward to public Face RotateAs(double tol, Vector3D from, Vector3D to) Parameters tol double from Vector3D to Vector3D Returns Face ToHatch(double, HatchPattern, bool) create hatch with outer and inner boundaries public Hatch? ToHatch(double tol, HatchPattern pattern, bool associative = true) Parameters tol double pattern HatchPattern associative bool Returns Hatch ToString() public override string ToString() Returns string"
  },
  "api/SearchAThing.Sci.GeomSegmentMode.html": {
    "href": "api/SearchAThing.Sci.GeomSegmentMode.html",
    "title": "Enum GeomSegmentMode | netcore-sci",
    "keywords": "Enum GeomSegmentMode Namespace SearchAThing.Sci Assembly netcore-sci.dll public enum GeomSegmentMode Fields From = 1 Semi-line start at From FromTo = 3 Segment from-to Infinite = 0 infinite line To = 2 Semi-line ending at To"
  },
  "api/SearchAThing.Sci.Geometry.html": {
    "href": "api/SearchAThing.Sci.Geometry.html",
    "title": "Class Geometry | netcore-sci",
    "keywords": "Class Geometry Namespace SearchAThing.Sci Assembly netcore-sci.dll base abstract type for geometries such as Vector3D, Line3D, Arc3D and Circle3D public abstract class Geometry Inheritance object Geometry Derived Edge Vector3D Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Geometry(GeometryType) protected Geometry(GeometryType type) Parameters type GeometryType Properties DxfEntity dxf entity representing this geom public abstract EntityObject DxfEntity { get; } Property Value EntityObject GeomFrom start point public abstract Vector3D GeomFrom { get; } Property Value Vector3D GeomTo end point public abstract Vector3D GeomTo { get; } Property Value Vector3D GeomType type of geometry public GeometryType GeomType { get; protected set; } Property Value GeometryType Length geometry length ( 0 for point, line length for lines, perimeter for arc/circles ) public abstract double Length { get; } Property Value double MidPoint public abstract Vector3D MidPoint { get; } Property Value Vector3D Vertexes vertexes of this geom ( can be 1 for points, 2 for line/arc/circles ) public abstract IEnumerable<Vector3D> Vertexes { get; } Property Value IEnumerable<Vector3D> Methods BBox(double) bbox of this geom public abstract BBox3D BBox(double tol) Parameters tol double Returns BBox3D Copy() create copy of this geometry. public abstract Geometry Copy() Returns Geometry Remarks it's required to call base.CopyFrom(other) to ensure geometry properties to be copied. Divide(int, bool) find split points for this geometry splitter int cnt parts public abstract IEnumerable<Vector3D> Divide(int cnt, bool include_endpoints = false) Parameters cnt int include_endpoints bool if true GeomFrom and GeomTo will added Returns IEnumerable<Vector3D> GeomEquals(double, Geometry, bool) states if this geom equals to given other public abstract bool GeomEquals(double tol, Geometry other, bool checkSense = false) Parameters tol double length tolerance other Geometry other geom checkSense bool if false two geometry with different sense but same space coverage are considered equals Returns bool GeomIntersect(double, Geometry, GeomSegmentMode, GeomSegmentMode) find intersections between this and another geometry resulting in zero or more geometries. public abstract IEnumerable<Geometry> GeomIntersect(double tol, Geometry other, GeomSegmentMode thisSegmentMode = GeomSegmentMode.FromTo, GeomSegmentMode otherSegmentMode = GeomSegmentMode.FromTo) Parameters tol double other Geometry thisSegmentMode GeomSegmentMode if this is Line3D specifies how to consider otherSegmentMode GeomSegmentMode if other is Line3D specifies how to consider Returns IEnumerable<Geometry> Move(Vector3D) public abstract Geometry Move(Vector3D delta) Parameters delta Vector3D Returns Geometry Split(double, IEnumerable<Vector3D>) split geometry in given break points. precondition: breaks must lie on the geometry perimeter public abstract IEnumerable<Geometry> Split(double tol, IEnumerable<Vector3D> breaks) Parameters tol double breaks IEnumerable<Vector3D> Returns IEnumerable<Geometry> Operators implicit operator EntityObject(Geometry) convert to dxf entity public static implicit operator EntityObject(Geometry geom) Parameters geom Geometry Returns EntityObject"
  },
  "api/SearchAThing.Sci.GeometryType.html": {
    "href": "api/SearchAThing.Sci.GeometryType.html",
    "title": "Enum GeometryType | netcore-sci",
    "keywords": "Enum GeometryType Namespace SearchAThing.Sci Assembly netcore-sci.dll public enum GeometryType Fields Arc3D = 3 Circle3D = 2 Line3D = 1 Vector3D = 0"
  },
  "api/SearchAThing.Sci.Int64Map.html": {
    "href": "api/SearchAThing.Sci.Int64Map.html",
    "title": "Class Int64Map | netcore-sci",
    "keywords": "Class Int64Map Namespace SearchAThing.Sci Assembly netcore-sci.dll Scan a given domain of doubles, determine the midpoint ( Origin ) and using the given tolerance it tests for integrity in conversion between values from double to Int64 and vice-versa. It can generate a Int64MapExceptionRange. public class Int64Map Inheritance object Int64Map Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Int64Map(double, IEnumerable<double>, bool) use small tolerance to avoid lost of precision Note: too small tolerance can generate Int64MapExceptionRange public Int64Map(double tol, IEnumerable<double> domainValues, bool selfCheckTolerance = true) Parameters tol double domainValues IEnumerable<double> selfCheckTolerance bool Properties Origin public double Origin { get; } Property Value double Tolerance public double Tolerance { get; } Property Value double Methods FromInt64(long) public double FromInt64(long x) Parameters x long Returns double ToInt64(double) public long ToInt64(double x) Parameters x double Returns long"
  },
  "api/SearchAThing.Sci.Int64MapExceptionRange.html": {
    "href": "api/SearchAThing.Sci.Int64MapExceptionRange.html",
    "title": "Class Int64MapExceptionRange | netcore-sci",
    "keywords": "Class Int64MapExceptionRange Namespace SearchAThing.Sci Assembly netcore-sci.dll public class Int64MapExceptionRange : Exception, ISerializable Inheritance object Exception Int64MapExceptionRange Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors Int64MapExceptionRange(string) public Int64MapExceptionRange(string msg) Parameters msg string"
  },
  "api/SearchAThing.Sci.LUT.html": {
    "href": "api/SearchAThing.Sci.LUT.html",
    "title": "Class LUT | netcore-sci",
    "keywords": "Class LUT Namespace SearchAThing.Sci Assembly netcore-sci.dll Lookup Table genertor public class LUT Inheritance object LUT Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors LUT(Func<double, double>, double, double, int) public LUT(Func<double, double> fx, double xFrom, double xTo, int lutSize) Parameters fx Func<double, double> xFrom double xTo double lutSize int Properties Fx public Func<double, double> Fx { get; } Property Value Func<double, double> LUTSize public int LUTSize { get; } Property Value int XFrom public double XFrom { get; } Property Value double XStep public double XStep { get; } Property Value double XTo public double XTo { get; } Property Value double YFrom public double YFrom { get; } Property Value double YStep public double YStep { get; } Property Value double YTo public double YTo { get; } Property Value double YXTable public IReadOnlyList<double> YXTable { get; } Property Value IReadOnlyList<double> Methods ComputeX(double) public double ComputeX(double y) Parameters y double Returns double"
  },
  "api/SearchAThing.Sci.Line3D.html": {
    "href": "api/SearchAThing.Sci.Line3D.html",
    "title": "Class Line3D | netcore-sci",
    "keywords": "Class Line3D Namespace SearchAThing.Sci Assembly netcore-sci.dll Defines a line by an application point (From) and an extension from there (V). To is computed as From+V. Line can be built by givin From and To, or From and V using specialized constructor with Line3DConstructMode. Line can be built from a point using LineTo(), LineV() or LineDir() extension methods. public class Line3D : Edge Inheritance object Geometry Edge Line3D Inherited Members Edge.CopyFrom(Edge) Edge.Sense Edge.SGeomFrom Edge.SGeomTo Edge.OtherEndpoint(double, Vector3D) Edge.EndpointMatches(double, Vector3D, Vector3D) Edge.EndpointMatches(double, Vector3D) Edge.CheckSense(double, Edge) Geometry.GeomType object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Extension Methods Ext.ToDxfLine(Line3D) Constructors Line3D(Line3D) build a copy of given line public Line3D(Line3D l) Parameters l Line3D Line3D(Vector3D, Vector3D) build segment public Line3D(Vector3D from, Vector3D to) Parameters from Vector3D to Vector3D Line3D(Vector3D, Vector3D, Line3DConstructMode) build segment from plus the given vector form to public Line3D(Vector3D from, Vector3D v, Line3DConstructMode mode) Parameters from Vector3D v Vector3D mode Line3DConstructMode Line3D(double, double, double, double) z=0 public Line3D(double x1, double y1, double x2, double y2) Parameters x1 double y1 double x2 double y2 double Line3D(double, double, double, double, double, double) public Line3D(double x1, double y1, double z1, double x2, double y2, double z2) Parameters x1 double y1 double z1 double x2 double y2 double z2 double Fields XAxisLine public static readonly Line3D XAxisLine Field Value Line3D YAxisLine public static readonly Line3D YAxisLine Field Value Line3D ZAxisLine public static readonly Line3D ZAxisLine Field Value Line3D Properties A0ProgeCadScript public string A0ProgeCadScript { get; } Property Value string A0QCadScript public string A0QCadScript { get; } Property Value string CadScript public string CadScript { get; } Property Value string Dir V normalized public Vector3D Dir { get; } Property Value Vector3D DisambiguatedPoints retrieve a unique endpoint representation of this line3d segment (regardless its from-to or to-from order) such that From.Distance(Vector3D.Zero) less than To.Distance(Vector3D.Zero) public IEnumerable<Vector3D> DisambiguatedPoints { get; } Property Value IEnumerable<Vector3D> DxfEntity dxf entity representing this geom public override EntityObject DxfEntity { get; } Property Value EntityObject From application point vector public Vector3D From { get; } Property Value Vector3D GeomFrom start point [JsonIgnore] public override Vector3D GeomFrom { get; } Property Value Vector3D GeomTo end point [JsonIgnore] public override Vector3D GeomTo { get; } Property Value Vector3D Inverted return inverted segment public Line3D Inverted { get; } Property Value Line3D Length geometry length ( 0 for point, line length for lines, perimeter for arc/circles ) public override double Length { get; } Property Value double MidPoint public override Vector3D MidPoint { get; } Property Value Vector3D Points public IEnumerable<Vector3D> Points { get; } Property Value IEnumerable<Vector3D> Swapped return segment with swapped from,to public Line3D Swapped { get; } Property Value Line3D To From + V public Vector3D To { get; } Property Value Vector3D V vector depart at From to identify To public Vector3D V { get; } Property Value Vector3D Vertexes vertexes of this geom ( can be 1 for points, 2 for line/arc/circles ) [JsonIgnore] public override IEnumerable<Vector3D> Vertexes { get; } Property Value IEnumerable<Vector3D> Methods ApparentIntersect(Line3D) Find apparent intersection between this and given other line returning (shortest) segment perpendicular to either lines or null if lines parallels. This method will used from Intersect to find intersection between lines when perpendicular segment length not exceed given length tolerance. public Line3D? ApparentIntersect(Line3D other) Parameters other Line3D other 3d line Returns Line3D Perp segment from(on this), to(on other). Remarks unit test BBox(double) bbox of this geom public override BBox3D BBox(double tol) Parameters tol double Returns BBox3D Bisect(double, Line3D, Vector3D?) returns bisect of two given segment/lines ( if given segment not share nodes but intesects returned bisect start from ip ) bisect choosen will be the one between this and other withing shortest angle if two given lines are parallel and parallelRotationAxis is given then bisect results as this segment rotated PI/2 about given axis using To as rotcenter public Line3D? Bisect(double tol, Line3D other, Vector3D? parallelRotationAxis = null) Parameters tol double length tolerance other Line3D parallelRotationAxis Vector3D Returns Line3D Colinear(double, Line3D) public bool Colinear(double tol, Line3D other) Parameters tol double other Line3D Returns bool CommonPoint(double, Line3D) returns the common point from,to between two lines or null if not consecutives public Vector3D? CommonPoint(double tol, Line3D other) Parameters tol double other Line3D Returns Vector3D Copy() create copy of this geometry. public override Geometry Copy() Returns Geometry Remarks it's required to call base.CopyFrom(other) to ensure geometry properties to be copied. Divide(int, bool) find split points for this geometry splitter int cnt parts public override IEnumerable<Vector3D> Divide(int cnt, bool include_endpoints = false) Parameters cnt int include_endpoints bool if true GeomFrom and GeomTo will added Returns IEnumerable<Vector3D> EdgeContainsPoint(double, Vector3D) States if edge contains given point on its perimeter public override bool EdgeContainsPoint(double tol, Vector3D pt) Parameters tol double pt Vector3D Returns bool EdgeMove(Vector3D) public Edge EdgeMove(Vector3D delta) Parameters delta Vector3D Returns Edge EnsureFrom(double, Vector3D) if this segment from matches the given point returns this; if this segment to matches the given point return this with from,to swapped; precondition: this segment must have from or to equals given from public Line3D EnsureFrom(double tol, Vector3D ptFromDesired) Parameters tol double length tolerance ptFromDesired Vector3D Returns Line3D EqualsTol(double, Line3D, bool) Checks if two lines are equals public bool EqualsTol(double tol, Line3D other, bool strict = false) Parameters tol double length tolerance other Line3D other line strict bool if false(default) two line equals even with swapped from,to Returns bool GeomEquals(double, Geometry, bool) states if this geom equals to given other public override bool GeomEquals(double tol, Geometry other, bool checkSense = false) Parameters tol double length tolerance other Geometry other geom checkSense bool if false two geometry with different sense but same space coverage are considered equals Returns bool GeomIntersect(double, Geometry, GeomSegmentMode, GeomSegmentMode) find intersections between this and another geometry resulting in zero or more geometries. public override IEnumerable<Geometry> GeomIntersect(double tol, Geometry _other, GeomSegmentMode thisSegmentMode = GeomSegmentMode.FromTo, GeomSegmentMode otherSegmentMode = GeomSegmentMode.FromTo) Parameters tol double _other Geometry thisSegmentMode GeomSegmentMode if this is Line3D specifies how to consider otherSegmentMode GeomSegmentMode if other is Line3D specifies how to consider Returns IEnumerable<Geometry> Intersect(double, CoordinateSystem3D) returns null if this line is parallel to the cs xy plane, the intersection point otherwise public Vector3D? Intersect(double tol, CoordinateSystem3D cs) Parameters tol double cs CoordinateSystem3D Returns Vector3D Intersect(double, Line3D, GeomSegmentMode, GeomSegmentMode) Intersects two lines with arbitrary segment mode for each. public Vector3D? Intersect(double tol, Line3D other, GeomSegmentMode thisSegmentMode, GeomSegmentMode otherSegmentMode) Parameters tol double other Line3D thisSegmentMode GeomSegmentMode otherSegmentMode GeomSegmentMode Returns Vector3D Intersect(double, Line3D, LineIntersectBehavior) Find intersection point between this and other line using given tolerance. Returns null if no intersection, otherwise it returns a point on the shortest segment ( the one that's perpendicular to either lines ) based on given behavior ( default midpoint ). public Vector3D? Intersect(double tol, Line3D other, LineIntersectBehavior behavior = LineIntersectBehavior.MidPoint) Parameters tol double other Line3D behavior LineIntersectBehavior Returns Vector3D Intersect(double, Line3D, bool, bool) Intersects two lines with arbitrary segment mode for each. public Vector3D? Intersect(double tol, Line3D other, bool thisSegment, bool otherSegment) Parameters tol double other Line3D thisSegment bool otherSegment bool Returns Vector3D Intersect(double, Plane3D) returns null if this line is parallel to the plane, the intersection point otherwise public Vector3D? Intersect(double tol, Plane3D plane) Parameters tol double plane Plane3D Returns Vector3D IsParallelTo(double, CoordinateSystem3D) public bool IsParallelTo(double tol, CoordinateSystem3D cs) Parameters tol double cs CoordinateSystem3D Returns bool IsParallelTo(double, Plane3D) public bool IsParallelTo(double tol, Plane3D plane) Parameters tol double plane Plane3D Returns bool LineContainsPoint(double, Vector3D, bool, bool) Infinite line contains point. public bool LineContainsPoint(double tol, Vector3D p, bool segmentMode = false, bool excludeExtreme = false) Parameters tol double p Vector3D segmentMode bool excludeExtreme bool Returns bool LineContainsPoint(double, double, double, double, bool) Infinite line contains point. Note: tol must be Constant.NormalizedLengthTolerance if comparing normalized vectors public bool LineContainsPoint(double tol, double x, double y, double z, bool segmentMode = false) Parameters tol double x double y double z double segmentMode bool Returns bool Move(Vector3D) move this segment of given delta public override Geometry Move(Vector3D delta) Parameters delta Vector3D Returns Geometry MoveEnd(double, EdgeEnd, Vector3D) extends edge endpoint toward new given one. returns null if edge can't extends toward new given end. public override Edge? MoveEnd(double tol, EdgeEnd end, Vector3D newEnd) Parameters tol double end EdgeEnd newEnd Vector3D Returns Edge MoveMidpoint(Vector3D) Move this segment midpoint to the given coord public Line3D MoveMidpoint(Vector3D newMidpoint) Parameters newMidpoint Vector3D Returns Line3D Normalized() build a segment with same from and vector normalized public Line3D Normalized() Returns Line3D Offset(double, Vector3D, double) create offseted line toward refPt for given offset public override Edge Offset(double tol, Vector3D refPt, double offset) Parameters tol double refPt Vector3D offset double Returns Edge Perpendicular(double, Vector3D) Build a perpendicular vector to this one starting from the given point p. public Line3D? Perpendicular(double tol, Vector3D p) Parameters tol double p Vector3D Returns Line3D ProgeCadScript(bool) public override string ProgeCadScript(bool final = true) Parameters final bool Returns string Project(double, Plane3D) project this line to given projection plane public override Edge Project(double tol, Plane3D prjPlane) Parameters tol double prjPlane Plane3D Returns Edge Project(double, Vector3D, bool) project given pt to this line public override Vector3D? Project(double tol, Vector3D pt, bool segment_mode = true) Parameters tol double pt Vector3D segment_mode bool Returns Vector3D QCadScript(bool) 2d qcad script representation ( vscode watch using var,nq ) public override string QCadScript(bool final = true) Parameters final bool Returns string Reverse() return the segment with swapped from,to public Line3D Reverse() Returns Line3D RotateAboutAxis(Line3D, double) rotate this segment about given axis public Line3D RotateAboutAxis(Line3D axisSegment, double angleRad) Parameters axisSegment Line3D angleRad double Returns Line3D Scale(Vector3D, double) scale from,to of this line using given refpt and factor public Line3D Scale(Vector3D refpt, double factor) Parameters refpt Vector3D factor double Returns Line3D Scale(double) scale from,to of this line using given factor and assuming refpt = MidPoint public Line3D Scale(double factor) Parameters factor double factor to scale this segment Returns Line3D scaled segment Remarks unit test SegmentContainsPoint(double, Vector3D, bool) Finite segment contains point. Note: tol must be Constant.NormalizedLengthTolerance if comparing normalized vectors public bool SegmentContainsPoint(double tol, Vector3D p, bool excludeExtreme = false) Parameters tol double p Vector3D excludeExtreme bool Returns bool SegmentContainsPoint(double, double, double, double) Finite segment contains point. Note: tol must be Constant.NormalizedLengthTolerance if comparing normalized vectors public bool SegmentContainsPoint(double tol, double x, double y, double z) Parameters tol double x double y double z double Returns bool SemiLineContainsPoint(double, Vector3D) states if semiline From-To(inf) contains given point public bool SemiLineContainsPoint(double tol, Vector3D p) Parameters tol double len tolerance p Vector3D point to verify is it on semiline Returns bool SetLength(double) resize this segment to a new one with same From public Line3D SetLength(double len) Parameters len double Returns Line3D Split(double, IEnumerable<Vector3D>) Split current segment into one or more depending on which of given split points was found on the segment. public override IEnumerable<Geometry> Split(double tol, IEnumerable<Vector3D> breaks) Parameters tol double length tolerance breaks IEnumerable<Vector3D> break points Returns IEnumerable<Geometry> splitted segments starts from begin of line ToString() build an invariant string representation w/3 digits (f.x, f.y, f.z)-(t.x, t.y, t.z) L=len Î”=(v.x, v.y, v.z) public override string ToString() Returns string ToString(int) build an invariant string representation w/given digits (f.x, f.y, f.z)-(t.x, t.y, t.z) L=len Î”=(v.x, v.y, v.z) public override string ToString(int digits = 3) Parameters digits int Returns string ToStringTol(double) hash string with given tolerance public string ToStringTol(double tol) Parameters tol double Returns string ToggleSense() public Line3D ToggleSense() Returns Line3D Transform(Matrix4x4) public Line3D Transform(Matrix4x4 transform) Parameters transform Matrix4x4 Returns Line3D Operators operator +(Line3D, Vector3D) Move this line of given delta adding value either at From, To public static Line3D operator +(Line3D l, Vector3D delta) Parameters l Line3D delta Vector3D Returns Line3D operator *(Line3D, double) multiply Length by given scalar factor Note : this will change To public static Line3D operator *(Line3D l, double s) Parameters l Line3D s double Returns Line3D operator *(double, Line3D) multiply Length by given scalar factor Note : this will change To public static Line3D operator *(double s, Line3D l) Parameters s double l Line3D Returns Line3D operator -(Line3D, Vector3D) Move this line of given delta subtracting value either at From, To public static Line3D operator -(Line3D l, Vector3D delta) Parameters l Line3D delta Vector3D Returns Line3D"
  },
  "api/SearchAThing.Sci.Line3DConstructMode.html": {
    "href": "api/SearchAThing.Sci.Line3DConstructMode.html",
    "title": "Enum Line3DConstructMode | netcore-sci",
    "keywords": "Enum Line3DConstructMode Namespace SearchAThing.Sci Assembly netcore-sci.dll public enum Line3DConstructMode Fields PointAndVector = 0"
  },
  "api/SearchAThing.Sci.Line3DEqualityComparer.html": {
    "href": "api/SearchAThing.Sci.Line3DEqualityComparer.html",
    "title": "Class Line3DEqualityComparer | netcore-sci",
    "keywords": "Class Line3DEqualityComparer Namespace SearchAThing.Sci Assembly netcore-sci.dll equality comparer helper for Line3D types public class Line3DEqualityComparer : IEqualityComparer<Line3D> Inheritance object Line3DEqualityComparer Implements IEqualityComparer<Line3D> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Line3DEqualityComparer(double, bool) constructor for line3d eq cmp public Line3DEqualityComparer(double _tol, bool _strict = false) Parameters _tol double length tolerance _strict bool if false(default) two line equals even with swapped from,to Methods Equals(Line3D?, Line3D?) public bool Equals(Line3D? x, Line3D? y) Parameters x Line3D y Line3D Returns bool GetHashCode(Line3D) public int GetHashCode(Line3D obj) Parameters obj Line3D Returns int"
  },
  "api/SearchAThing.Sci.LineIntersectBehavior.html": {
    "href": "api/SearchAThing.Sci.LineIntersectBehavior.html",
    "title": "Enum LineIntersectBehavior | netcore-sci",
    "keywords": "Enum LineIntersectBehavior Namespace SearchAThing.Sci Assembly netcore-sci.dll public enum LineIntersectBehavior Fields MidPoint = 0 PointOnOther = 2 PointOnThis = 1"
  },
  "api/SearchAThing.Sci.Loop.html": {
    "href": "api/SearchAThing.Sci.Loop.html",
    "title": "Class Loop | netcore-sci",
    "keywords": "Class Loop Namespace SearchAThing.Sci Assembly netcore-sci.dll planar edges loop containing line and arcs public class Loop Inheritance object Loop Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Extension Methods Ext.ToFace(Loop) Constructors Loop(double, Plane3D, IEnumerable<Edge>, bool, bool) precondition: edges must lie on given plane public Loop(double tol, Plane3D plane, IEnumerable<Edge> _edges, bool checkSense, bool checkSort = false) Parameters tol double plane Plane3D _edges IEnumerable<Edge> checkSense bool checkSort bool Loop(double, IEnumerable<Edge>, Plane3D, bool) create loop from given edges, plane template public Loop(double tol, IEnumerable<Edge> edges, Plane3D plane, bool checkSense = true) Parameters tol double edges IEnumerable<Edge> plane Plane3D checkSense bool Loop(double, IEnumerable<Edge>, bool, bool) create loop from given edge template ; plane is detected from edges distribution public Loop(double tol, IEnumerable<Edge> edges, bool checkSense = true, bool checkSort = false) Parameters tol double edges IEnumerable<Edge> checkSense bool checkSort bool Loop(double, Polyline2D) create a loop from given lwpolyline template public Loop(double tol, Polyline2D lwPolyline) Parameters tol double lwPolyline Polyline2D Properties A0ProgeCadScript public string A0ProgeCadScript { get; } Property Value string A0QCadScript public string A0QCadScript { get; } Property Value string Area (cached) area of the loop ( segment and arc are evaluated ) public double Area { get; } Property Value double BBox (cached) bbox of this loop WCS coords public BBox3D BBox { get; } Property Value BBox3D CSBox (cached) bbox of this loop CS coords public BBox3D CSBox { get; } Property Value BBox3D Edges loop edges ( line, arc ) public IReadOnlyList<Edge> Edges { get; } Property Value IReadOnlyList<Edge> Length (cached) loop perimeter length public double Length { get; } Property Value double MidPoint (cached) geometric midpoint of all edges midpoint of this loop ( used in Contains for ray construction ) public Vector3D MidPoint { get; } Property Value Vector3D Plane plane where loop edges resides public Plane3D Plane { get; } Property Value Plane3D Tol public double Tol { get; } Property Value double Methods Contains(double, Edge, LoopContainsEdgeMode) test if given edge contained in this loop public bool Contains(double tol, Edge edge, LoopContainsEdgeMode mode = LoopContainsEdgeMode.InsideOrPerimeter) Parameters tol double edge Edge mode LoopContainsEdgeMode Returns bool Contains(double, Loop, LoopContainsEdgeMode) states if this loop contains given other loop public bool Contains(double tol, Loop other, LoopContainsEdgeMode mode = LoopContainsEdgeMode.InsideOrPerimeter) Parameters tol double other Loop mode LoopContainsEdgeMode Returns bool ContainsPoint(double, Vector3D, LoopContainsPointMode) states if given point is included into this loop public bool ContainsPoint(double tol, Vector3D pt, LoopContainsPointMode mode) Parameters tol double pt Vector3D mode LoopContainsPointMode Returns bool DebugDump(int) public string DebugDump(int digits = 3) Parameters digits int Returns string DxfEntity(double) create dxf lwpolyline from this loop public Polyline2D DxfEntity(double tol) Parameters tol double Returns Polyline2D Equals(double, Loop) check if two loops equals public bool Equals(double tol, Loop other) Parameters tol double other Loop Returns bool InvertSense(double) retrieve another loop with reversed edges with sense toggled public Loop InvertSense(double tol) Parameters tol double Returns Loop Move(Vector3D) move loop (plane and edges) of given delta public Loop Move(Vector3D delta) Parameters delta Vector3D Returns Loop ProgeCadScript(bool) public string ProgeCadScript(bool final = true) Parameters final bool Returns string QCadScript(bool) qcad 2d script public string QCadScript(bool final = true) Parameters final bool adds QQ command Returns string ToHatch(double, HatchPattern, bool) create an hatch from given loop, pattern public Hatch ToHatch(double tol, HatchPattern pattern, bool associative = true) Parameters tol double pattern HatchPattern associative bool Returns Hatch ToLwPolyline(double) create dxf lwpolyline from this loop public Polyline2D ToLwPolyline(double tol) Parameters tol double Returns Polyline2D ToString() public override string ToString() Returns string Vertexes(double) loop edge distinct filtered vertexes ( not optimized ) public IEnumerable<Vector3D> Vertexes(double tol) Parameters tol double Returns IEnumerable<Vector3D>"
  },
  "api/SearchAThing.Sci.LoopContainsEdgeMode.html": {
    "href": "api/SearchAThing.Sci.LoopContainsEdgeMode.html",
    "title": "Enum LoopContainsEdgeMode | netcore-sci",
    "keywords": "Enum LoopContainsEdgeMode Namespace SearchAThing.Sci Assembly netcore-sci.dll public enum LoopContainsEdgeMode Fields InsideExcludedPerimeter = 1 point is inside (perimeter excluded) InsideOrPerimeter = 2 point is inside or on perimeter MidPointInside = 3 midpoint is inside Perimeter = 0 point is on perimeter"
  },
  "api/SearchAThing.Sci.LoopContainsPointMode.html": {
    "href": "api/SearchAThing.Sci.LoopContainsPointMode.html",
    "title": "Enum LoopContainsPointMode | netcore-sci",
    "keywords": "Enum LoopContainsPointMode Namespace SearchAThing.Sci Assembly netcore-sci.dll public enum LoopContainsPointMode Fields InsideExcludedPerimeter = 1 point is inside (perimeter excluded) InsideOrPerimeter = 2 point is inside or on perimeter Perimeter = 0 point is on perimeter"
  },
  "api/SearchAThing.Sci.LoopEqualityComparer.html": {
    "href": "api/SearchAThing.Sci.LoopEqualityComparer.html",
    "title": "Class LoopEqualityComparer | netcore-sci",
    "keywords": "Class LoopEqualityComparer Namespace SearchAThing.Sci Assembly netcore-sci.dll public class LoopEqualityComparer : IEqualityComparer<Loop> Inheritance object LoopEqualityComparer Implements IEqualityComparer<Loop> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors LoopEqualityComparer(double) public LoopEqualityComparer(double tol) Parameters tol double Methods Equals(Loop?, Loop?) public bool Equals(Loop? x, Loop? y) Parameters x Loop y Loop Returns bool GetHashCode(Loop) public int GetHashCode(Loop obj) Parameters obj Loop Returns int"
  },
  "api/SearchAThing.Sci.Matrix3D.html": {
    "href": "api/SearchAThing.Sci.Matrix3D.html",
    "title": "Class Matrix3D | netcore-sci",
    "keywords": "Class Matrix3D Namespace SearchAThing.Sci Assembly netcore-sci.dll basic matrix3d with 3x3 double elements and operations to allow arithmetic and 3d linear equation resolution. public class Matrix3D Inheritance object Matrix3D Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Matrix3D() empty matrix public Matrix3D() Matrix3D(double[]) Init matrix using terms m00 m01 m02 - m10 m11 m12 - m20 m21 m22 public Matrix3D(double[] terms) Parameters terms double[] Properties this[int, int] indexed matrix component [row,col] public double this[int r, int c] { get; } Parameters r int c int Property Value double Methods Adjoint() Adjoint matrix http://www.mathsisfun.com/algebra/matrix-inverse-minors-cofactors-adjugate.html public Matrix3D Adjoint() Returns Matrix3D Cofactor() Matrix of cofactors http://www.mathsisfun.com/algebra/matrix-inverse-minors-cofactors-adjugate.html public Matrix3D Cofactor() Returns Matrix3D CopyVectorAsColumn(Vector3D, int) public Matrix3D CopyVectorAsColumn(Vector3D v, int colIdx) Parameters v Vector3D colIdx int Returns Matrix3D CopyVectorAsRow(Vector3D, int) public Matrix3D CopyVectorAsRow(Vector3D v, int rowIdx) Parameters v Vector3D rowIdx int Returns Matrix3D Determinant() Matrix determinant http://mathcentral.uregina.ca/QQ/database/QQ.09.06/h/suud1.html public double Determinant() Returns double EqualsTol(double, Matrix3D) public bool EqualsTol(double tol, Matrix3D other) Parameters tol double other Matrix3D Returns bool FromVectorsAsColumns(Vector3D, Vector3D, Vector3D) public static Matrix3D FromVectorsAsColumns(Vector3D v1, Vector3D v2, Vector3D v3) Parameters v1 Vector3D v2 Vector3D v3 Vector3D Returns Matrix3D FromVectorsAsRows(Vector3D, Vector3D, Vector3D) public static Matrix3D FromVectorsAsRows(Vector3D v1, Vector3D v2, Vector3D v3) Parameters v1 Vector3D v2 Vector3D v3 Vector3D Returns Matrix3D Inverse() Inverse matrix http://www.mathsisfun.com/algebra/matrix-inverse-minors-cofactors-adjugate.html public Matrix3D Inverse() Returns Matrix3D Minor() Matrix of minors http://www.mathsisfun.com/algebra/matrix-inverse-minors-cofactors-adjugate.html public Matrix3D Minor() Returns Matrix3D Solve(Vector3D) Solve linear system of eq represented by this matrix defined n known term. Ax = B -> x = A^(-1)B public Vector3D Solve(Vector3D n) Parameters n Vector3D Returns Vector3D Solve(double, double, double) Solve linear system of eq represented by this matrix defined (a,b,c) known terms. public Vector3D Solve(double a, double b, double c) Parameters a double b double c double Returns Vector3D Transpose() swap row, cols public Matrix3D Transpose() Returns Matrix3D Operators operator +(Matrix3D, Matrix3D) sum public static Matrix3D operator +(Matrix3D a, Matrix3D b) Parameters a Matrix3D b Matrix3D Returns Matrix3D operator /(Matrix3D, double) scalar div public static Matrix3D operator /(Matrix3D m, double s) Parameters m Matrix3D s double Returns Matrix3D operator /(double, Matrix3D) scalar div public static Matrix3D operator /(double s, Matrix3D m) Parameters s double m Matrix3D Returns Matrix3D operator *(Matrix3D, Vector3D) matrix * vector as column -> vector 3x3 x 3x1 -> 3x1 public static Vector3D operator *(Matrix3D m, Vector3D v) Parameters m Matrix3D v Vector3D Returns Vector3D operator *(Matrix3D, double) scalar multiply public static Matrix3D operator *(Matrix3D m, double s) Parameters m Matrix3D s double Returns Matrix3D operator *(Vector3D, Matrix3D) vector as row * matrix -> vector 1x3 * 3x3 -> 1x3 public static Vector3D operator *(Vector3D v, Matrix3D m) Parameters v Vector3D m Matrix3D Returns Vector3D operator *(double, Matrix3D) scalar multiply public static Matrix3D operator *(double s, Matrix3D m) Parameters s double m Matrix3D Returns Matrix3D operator -(Matrix3D, Matrix3D) sub public static Matrix3D operator -(Matrix3D a, Matrix3D b) Parameters a Matrix3D b Matrix3D Returns Matrix3D operator -(Matrix3D) neg public static Matrix3D operator -(Matrix3D m) Parameters m Matrix3D Returns Matrix3D"
  },
  "api/SearchAThing.Sci.NVector3EqualityComparer.html": {
    "href": "api/SearchAThing.Sci.NVector3EqualityComparer.html",
    "title": "Class NVector3EqualityComparer | netcore-sci",
    "keywords": "Class NVector3EqualityComparer Namespace SearchAThing.Sci Assembly netcore-sci.dll helper class to compare vector3d set using given tolerance public class NVector3EqualityComparer : IEqualityComparer<Vector3> Inheritance object NVector3EqualityComparer Implements IEqualityComparer<Vector3> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors NVector3EqualityComparer(double) public NVector3EqualityComparer(double _tol) Parameters _tol double Methods Equals(Vector3, Vector3) public bool Equals(Vector3 a, Vector3 b) Parameters a Vector3 b Vector3 Returns bool GetHashCode(Vector3) public int GetHashCode(Vector3 obj) Parameters obj Vector3 Returns int"
  },
  "api/SearchAThing.Sci.NormalizedAngleComparer.html": {
    "href": "api/SearchAThing.Sci.NormalizedAngleComparer.html",
    "title": "Class NormalizedAngleComparer | netcore-sci",
    "keywords": "Class NormalizedAngleComparer Namespace SearchAThing.Sci Assembly netcore-sci.dll normalized angles in range [StartAngle, EndAngle] comparer Example: start:1.25Ï€ end:0.5Ï€ the set { 0.25Ï€, 0.75Ï€ } sorts to { 0.75Ï€, 0.25Ï€ } Precondition: constructor start, end angles and compare method arguments must normalized [0,2PI) public class NormalizedAngleComparer : IComparer<double> Inheritance object NormalizedAngleComparer Implements IComparer<double> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors NormalizedAngleComparer(double, double) public NormalizedAngleComparer(double normalizedStartAngleRad, double normalizedEndAngleRad) Parameters normalizedStartAngleRad double normalizedEndAngleRad double Properties NormalizedEndAngleRad public double NormalizedEndAngleRad { get; } Property Value double NormalizedStartAngleRad public double NormalizedStartAngleRad { get; } Property Value double Methods Compare(double, double) compare two angles ; precondition: angles must already normalized public int Compare(double xAngleRad, double yAngleRad) Parameters xAngleRad double yAngleRad double Returns int"
  },
  "api/SearchAThing.Sci.NumbersStatNfo.html": {
    "href": "api/SearchAThing.Sci.NumbersStatNfo.html",
    "title": "Struct NumbersStatNfo | netcore-sci",
    "keywords": "Struct NumbersStatNfo Namespace SearchAThing.Sci Assembly netcore-sci.dll statistical info about number set public struct NumbersStatNfo Inherited Members ValueType.Equals(object) ValueType.GetHashCode() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields Average public double Average Field Value double Count public int Count Field Value int Median public double Median Field Value double Mode public double? Mode Field Value double? Range public double Range Field Value double Similarity public double Similarity Field Value double StandardDeviation public double StandardDeviation Field Value double StandardDeviationP public double StandardDeviationP Field Value double Variance public double Variance Field Value double VarianceP public double VarianceP Field Value double Methods ToString() public override string ToString() Returns string"
  },
  "api/SearchAThing.Sci.OrdIdx.html": {
    "href": "api/SearchAThing.Sci.OrdIdx.html",
    "title": "Enum OrdIdx | netcore-sci",
    "keywords": "Enum OrdIdx Namespace SearchAThing.Sci Assembly netcore-sci.dll public enum OrdIdx Fields X = 0 Y = 1 Z = 2"
  },
  "api/SearchAThing.Sci.Plane3D.html": {
    "href": "api/SearchAThing.Sci.Plane3D.html",
    "title": "Class Plane3D | netcore-sci",
    "keywords": "Class Plane3D Namespace SearchAThing.Sci Assembly netcore-sci.dll encapsulate a CS to define a plane3d public class Plane3D Inheritance object Plane3D Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors Plane3D(CoordinateSystem3D) build plane using cs as reference for origin and x,y axes public Plane3D(CoordinateSystem3D cs) Parameters cs CoordinateSystem3D Fields XY XY(z) plane : top view public static readonly Plane3D XY Field Value Plane3D XZ XZ(-y) plane : front view public static readonly Plane3D XZ Field Value Plane3D YZ YZ(x) plane : side view public static readonly Plane3D YZ Field Value Plane3D Properties CS public CoordinateSystem3D CS { get; } Property Value CoordinateSystem3D Methods Contains(double, Edge) states if given edge contained in this plane public bool Contains(double tol, Edge edge) Parameters tol double edge Edge Returns bool Contains(double, Line3D) states if given wcs segment is contained in this plane public bool Contains(double tol, Line3D line) Parameters tol double line Line3D Returns bool Contains(double, Vector3D) states if given wcs point is contained in this plane public bool Contains(double tol, Vector3D pt) Parameters tol double pt Vector3D Returns bool Intersect(double, Plane3D) return intersection line between two planes or null if they parallels public Line3D? Intersect(double tol, Plane3D other) Parameters tol double len tolerance other Plane3D other plane Returns Line3D MiddlePlane(double, Plane3D) retrieve the plane that is in the middle between this and other given public Plane3D MiddlePlane(double tol, Plane3D other) Parameters tol double other Plane3D Returns Plane3D Move(Vector3D) public Plane3D Move(Vector3D delta) Parameters delta Vector3D Returns Plane3D ToString() public override string ToString() Returns string ToString(int) public string ToString(int digits) Parameters digits int Returns string"
  },
  "api/SearchAThing.Sci.Plane3DRegion.html": {
    "href": "api/SearchAThing.Sci.Plane3DRegion.html",
    "title": "Class Plane3DRegion | netcore-sci",
    "keywords": "Class Plane3DRegion Namespace SearchAThing.Sci Assembly netcore-sci.dll region of a plane3d delimited by a set of coplanar points public class Plane3DRegion Inheritance object Plane3DRegion Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Plane3DRegion(double, IEnumerable<Vector3D>) build plane3d region based upong given list of pts ( at least 3 non colinear points required ) public Plane3DRegion(double tol, IEnumerable<Vector3D> _pts) Parameters tol double length tolerance _pts IEnumerable<Vector3D> region points Properties CSPoints (coplanar) points delimiting region of plane3d in CS coordinates ( Z = 0 ) public IReadOnlyList<Vector3D> CSPoints { get; } Property Value IReadOnlyList<Vector3D> Plane plane info, contains CS public Plane3D Plane { get; } Property Value Plane3D Points (coplanar) points delimiting region of plane3d in WCS coordinates public IReadOnlyList<Vector3D> Points { get; } Property Value IReadOnlyList<Vector3D> Methods Contains(double, Vector3D) states if this plane3d region contains given point public bool Contains(double tol, Vector3D p) Parameters tol double length tolerance p Vector3D point to check if contained Returns bool true if given point is in plane3d region Intersect(double, Line3D) states if given ray line intersect this plane3d region public Vector3D? Intersect(double tol, Line3D ray) Parameters tol double length tolerance ray Line3D ray to test if intersect plane3d region Returns Vector3D intersection point or null if not"
  },
  "api/SearchAThing.Sci.PythonException.html": {
    "href": "api/SearchAThing.Sci.PythonException.html",
    "title": "Class PythonException | netcore-sci",
    "keywords": "Class PythonException Namespace SearchAThing.Sci Assembly netcore-sci.dll public class PythonException : Exception, ISerializable Inheritance object Exception PythonException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors PythonException(string, string) public PythonException(string errmsg, string output) Parameters errmsg string output string Properties Error stderr result public string Error { get; } Property Value string Output stdout result public string Output { get; } Property Value string Methods ToString() public override string ToString() Returns string"
  },
  "api/SearchAThing.Sci.PythonPipe.html": {
    "href": "api/SearchAThing.Sci.PythonPipe.html",
    "title": "Class PythonPipe | netcore-sci",
    "keywords": "Class PythonPipe Namespace SearchAThing.Sci Assembly netcore-sci.dll Helper to invoke python and retrieve results. public class PythonPipe : IDisposable Inheritance object PythonPipe Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PythonPipe(PythonPipeOptions?) public PythonPipe(PythonPipeOptions? options = null) Parameters options PythonPipeOptions Fields areInit public AutoResetEvent areInit Field Value AutoResetEvent Properties Options public PythonPipeOptions Options { get; } Property Value PythonPipeOptions Methods Dispose() public void Dispose() Exec(IEnumerable<string>) exec given code lines public Task<string> Exec(IEnumerable<string> code_lines) Parameters code_lines IEnumerable<string> Returns Task<string> Exec(string) exec given code ( can contains newlines as read from a file ). Actually only one execution per PythonPipe object is allowed. public Task<string> Exec(string code) Parameters code string Returns Task<string>"
  },
  "api/SearchAThing.Sci.PythonPipeOnErrorResultEnum.html": {
    "href": "api/SearchAThing.Sci.PythonPipeOnErrorResultEnum.html",
    "title": "Enum PythonPipeOnErrorResultEnum | netcore-sci",
    "keywords": "Enum PythonPipeOnErrorResultEnum Namespace SearchAThing.Sci Assembly netcore-sci.dll public enum PythonPipeOnErrorResultEnum Fields GenerateException = 1 Ignore = 0"
  },
  "api/SearchAThing.Sci.PythonPipeOptions.html": {
    "href": "api/SearchAThing.Sci.PythonPipeOptions.html",
    "title": "Class PythonPipeOptions | netcore-sci",
    "keywords": "Class PythonPipeOptions Namespace SearchAThing.Sci Assembly netcore-sci.dll public class PythonPipeOptions Inheritance object PythonPipeOptions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields PythonArgs allow to specify custom arguments in place of default \"-i\" argument public string? PythonArgs Field Value string PythonExecutablePathfilename allow to override environment python executable pathfilename public string? PythonExecutablePathfilename Field Value string Properties Debug debug messages of pythonpipe execution public Action<string>? Debug { get; set; } Property Value Action<string> OnError action called when error message reported and allow to ignore by returning OnErrorResultEnum.Ignore public Func<string, PythonPipeOnErrorResultEnum>? OnError { get; set; } Property Value Func<string, PythonPipeOnErrorResultEnum> OnOutput action called when output from pipe ( full output already results from python exec ) public Action<string>? OnOutput { get; set; } Property Value Action<string>"
  },
  "api/SearchAThing.Sci.SmartCsMode.html": {
    "href": "api/SearchAThing.Sci.SmartCsMode.html",
    "title": "Enum SmartCsMode | netcore-sci",
    "keywords": "Enum SmartCsMode Namespace SearchAThing.Sci Assembly netcore-sci.dll public enum SmartCsMode Fields X_YQ = 0 first vector must parallel csXaxis ; second vector must lie on desired csXY plane and not parallel to csXaxis ; csZaxis is computed as csXaxis cross second vector Z_X = 1 first vector must parallel to csZaxis ; second vector must parallel to csXaxis Z_Y = 2 first vector must parallel to csZaxis ; second vector must parallel to csYaxis"
  },
  "api/SearchAThing.Sci.Toolkit.SciPropertiesResolver.html": {
    "href": "api/SearchAThing.Sci.Toolkit.SciPropertiesResolver.html",
    "title": "Class Toolkit.SciPropertiesResolver | netcore-sci",
    "keywords": "Class Toolkit.SciPropertiesResolver Namespace SearchAThing.Sci Assembly netcore-sci.dll addictional json resolver to ignore some Vector3D, Line3D properties during serialization without affecting source code public class Toolkit.SciPropertiesResolver : PrivateSetterContractResolver, IContractResolver Inheritance object DefaultContractResolver PrivateSetterContractResolver Toolkit.SciPropertiesResolver Implements IContractResolver Inherited Members DefaultContractResolver.ResolveContract(Type) DefaultContractResolver.GetSerializableMembers(Type) DefaultContractResolver.CreateObjectContract(Type) DefaultContractResolver.CreateConstructorParameters(ConstructorInfo, JsonPropertyCollection) DefaultContractResolver.CreatePropertyFromConstructorParameter(JsonProperty, ParameterInfo) DefaultContractResolver.ResolveContractConverter(Type) DefaultContractResolver.CreateDictionaryContract(Type) DefaultContractResolver.CreateArrayContract(Type) DefaultContractResolver.CreatePrimitiveContract(Type) DefaultContractResolver.CreateLinqContract(Type) DefaultContractResolver.CreateISerializableContract(Type) DefaultContractResolver.CreateDynamicContract(Type) DefaultContractResolver.CreateStringContract(Type) DefaultContractResolver.CreateContract(Type) DefaultContractResolver.CreateProperties(Type, MemberSerialization) DefaultContractResolver.CreateMemberValueProvider(MemberInfo) DefaultContractResolver.ResolvePropertyName(string) DefaultContractResolver.ResolveExtensionDataName(string) DefaultContractResolver.ResolveDictionaryKey(string) DefaultContractResolver.GetResolvedPropertyName(string) DefaultContractResolver.DynamicCodeGeneration DefaultContractResolver.DefaultMembersSearchFlags DefaultContractResolver.SerializeCompilerGeneratedMembers DefaultContractResolver.IgnoreSerializableInterface DefaultContractResolver.IgnoreSerializableAttribute DefaultContractResolver.IgnoreIsSpecifiedMembers DefaultContractResolver.IgnoreShouldSerializeMembers DefaultContractResolver.NamingStrategy object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods CreateProperty(MemberInfo, MemberSerialization) Creates a Newtonsoft.Json.Serialization.JsonProperty for the given MemberInfo. protected override JsonProperty CreateProperty(MemberInfo member, MemberSerialization memberSerialization) Parameters member MemberInfo The member to create a Newtonsoft.Json.Serialization.JsonProperty for. memberSerialization MemberSerialization The member's parent Newtonsoft.Json.MemberSerialization. Returns JsonProperty A created Newtonsoft.Json.Serialization.JsonProperty for the given MemberInfo."
  },
  "api/SearchAThing.Sci.Toolkit.UnitJsonConverter-1.html": {
    "href": "api/SearchAThing.Sci.Toolkit.UnitJsonConverter-1.html",
    "title": "Class Toolkit.UnitJsonConverter<TUnitType> | netcore-sci",
    "keywords": "Class Toolkit.UnitJsonConverter<TUnitType> Namespace SearchAThing.Sci Assembly netcore-sci.dll json converter to write unit using abbrev public class Toolkit.UnitJsonConverter<TUnitType> : JsonConverter<TUnitType> where TUnitType : Enum Type Parameters TUnitType json converter to write unit using abbrev Inheritance object JsonConverter JsonConverter<TUnitType> Toolkit.UnitJsonConverter<TUnitType> Inherited Members JsonConverter<TUnitType>.WriteJson(JsonWriter, object, JsonSerializer) JsonConverter<TUnitType>.ReadJson(JsonReader, Type, object, JsonSerializer) JsonConverter<TUnitType>.CanConvert(Type) JsonConverter.CanRead JsonConverter.CanWrite object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods ReadJson(JsonReader, Type, TUnitType?, bool, JsonSerializer) Reads the JSON representation of the object. public override TUnitType? ReadJson(JsonReader reader, Type objectType, TUnitType? existingValue, bool hasExistingValue, JsonSerializer serializer) Parameters reader JsonReader The Newtonsoft.Json.JsonReader to read from. objectType Type Type of the object. existingValue TUnitType The existing value of object being read. If there is no existing value then null will be used. hasExistingValue bool The existing value has a value. serializer JsonSerializer The calling serializer. Returns TUnitType The object value. WriteJson(JsonWriter, TUnitType?, JsonSerializer) Writes the JSON representation of the object. public override void WriteJson(JsonWriter writer, TUnitType? value, JsonSerializer serializer) Parameters writer JsonWriter The Newtonsoft.Json.JsonWriter to write to. value TUnitType The value. serializer JsonSerializer The calling serializer."
  },
  "api/SearchAThing.Sci.Toolkit.WalkEdgeStopConditionDelegate.html": {
    "href": "api/SearchAThing.Sci.Toolkit.WalkEdgeStopConditionDelegate.html",
    "title": "Delegate Toolkit.WalkEdgeStopConditionDelegate | netcore-sci",
    "keywords": "Delegate Toolkit.WalkEdgeStopConditionDelegate Namespace SearchAThing.Sci Assembly netcore-sci.dll public delegate bool Toolkit.WalkEdgeStopConditionDelegate(Vector3D startVertex, Vector3D nextVertex) Parameters startVertex Vector3D nextVertex Vector3D Returns bool"
  },
  "api/SearchAThing.Sci.Toolkit.html": {
    "href": "api/SearchAThing.Sci.Toolkit.html",
    "title": "Class Toolkit | netcore-sci",
    "keywords": "Class Toolkit Namespace SearchAThing.Sci Assembly netcore-sci.dll netcore-sci toolkit static methods public static class Toolkit Inheritance object Toolkit Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields PostProcessCadScript public static Func<string, string> PostProcessCadScript Field Value Func<string, string> Properties SciJsonSettings public static JsonSerializerSettings SciJsonSettings { get; } Property Value JsonSerializerSettings Methods Circle2D(double, double, Vector3D, Vector3D) create circle 2D by given two points and radius public static Vector3D[] Circle2D(double tol, double radius, Vector3D p1, Vector3D p2) Parameters tol double length tolerance radius double circle radius p1 Vector3D circle first point (z not considered) p2 Vector3D circle second point (z not considered) Returns Vector3D[] circle centers CirclesOuterTangent(double, double, double, double, double, double) Finds tangent segments between two given circles. returns empty, or 2 tuple (exterior tangents) or 4 tuple (two exterior tangents and two interior tangents) ref: https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Tangents_between_two_circles public static IEnumerable<(CircleTangentType type, Vector3D pa, Vector3D pb)> CirclesOuterTangent(double x1, double y1, double r1, double x2, double y2, double r2) Parameters x1 double y1 double r1 double x2 double y2 double r2 double Returns IEnumerable<(CircleTangentType type, Vector3D pa, Vector3D pb)> Cube(Vector3D, double) Creates dxf entities for a 6 faces of a cube; generated face order is front, back, left, right, bottom, top public static IEnumerable<Face3D> Cube(Vector3D center, double L) Parameters center Vector3D L double Returns IEnumerable<Face3D> Cuboid(Vector3D, Vector3D) Creates dxf entities for 6 faces of a cuboid; generated face order is front, back, left, right, bottom, top public static IEnumerable<Face3D> Cuboid(Vector3D center, Vector3D size) Parameters center Vector3D size Vector3D Returns IEnumerable<Face3D> LinearSplineInterpolate(IEnumerable<double>, IEnumerable<double>) (MathNet.Numerics bookmark function) \"Create a linear spline interpolation from an unsorted set of (x,y) value pairs.\" then invoke Interpolate with x value to retrieve interpolated y value. For more interpolator see https://numerics.mathdotnet.com/api/MathNet.Numerics.Interpolation/index.htm public static IInterpolation LinearSplineInterpolate(IEnumerable<double> x, IEnumerable<double> y) Parameters x IEnumerable<double> y IEnumerable<double> Returns IInterpolation Remarks unit test Range(double, double, double, double, bool) span a range of doubles from start to end ( optionally included ) stepping with given inc public static IEnumerable<double> Range(double tol, double start, double end, double inc, bool includeEnd = false) Parameters tol double measure tolerance start double start pos end double end pos inc double increment includeEnd bool if true end can included in result set Returns IEnumerable<double> enumeration of discrete range items Segments(Face3D) retrieve 3 or 4 segments from given face public static IEnumerable<Line3D> Segments(this Face3D face) Parameters face Face3D Returns IEnumerable<Line3D> Star(Vector3D, double) Creates dxf entities for a 3 axis of given length centered in given center point. public static IEnumerable<Line> Star(Vector3D center, double L) Parameters center Vector3D L double Returns IEnumerable<Line> ToRegion(Face3D, double) convert face3d to Plane3DRegion public static Plane3DRegion ToRegion(this Face3D face, double tol) Parameters face Face3D tol double Returns Plane3DRegion ToSciJson(object) public static string ToSciJson(object o) Parameters o object Returns string Vertexes(Face3D) retrieve 3 or 4 vertex from given face public static IEnumerable<Vector3D> Vertexes(this Face3D face) Parameters face Face3D Returns IEnumerable<Vector3D> WalkEdges(double, Edge, Vector3D, Dictionary<Vector3D, List<Edge>>, WalkEdgeStopConditionDelegate?) walk edges public static IEnumerable<Edge> WalkEdges(double tol, Edge startEdge, Vector3D startVertex, Dictionary<Vector3D, List<Edge>> vertexToEdges, Toolkit.WalkEdgeStopConditionDelegate? stopCondition = null) Parameters tol double length tolerance startEdge Edge starting edge startVertex Vector3D starting vertex vertexToEdges Dictionary<Vector3D, List<Edge>> vertex to edges dictionary stopCondition Toolkit.WalkEdgeStopConditionDelegate by default stop when meet startvertex again Returns IEnumerable<Edge> walked edges"
  },
  "api/SearchAThing.Sci.Transform3D.html": {
    "href": "api/SearchAThing.Sci.Transform3D.html",
    "title": "Class Transform3D | netcore-sci",
    "keywords": "Class Transform3D Namespace SearchAThing.Sci Assembly netcore-sci.dll Use quaternion to append rotate transformations public class Transform3D Inheritance object Transform3D Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks unit test Constructors Transform3D() instantiate an identity transformation public Transform3D() Remarks unit test Methods Apply(Vector3D) apply this transformation to given vector returning new one public Vector3D Apply(Vector3D v) Parameters v Vector3D vector to transform Returns Vector3D Remarks unit test RotateAboutAxis(Vector3D, double) add rotation about given axis of given angle to the current rotation matrix. given axis will subjected to normalization public void RotateAboutAxis(Vector3D axis, double angleRad) Parameters axis Vector3D custom rotation axis angleRad double rotation angle about given axis Remarks unit test RotateAboutXAxis(double) add rotation about X axis of given angle to the current rotation matrix public void RotateAboutXAxis(double angleRad) Parameters angleRad double rotation angle about X axis Remarks unit test RotateAboutYAxis(double) add rotation about Y axis of given angle to the current rotation matrix public void RotateAboutYAxis(double angleRad) Parameters angleRad double rotation angle about Y axis Remarks unit test RotateAboutZAxis(double) add rotation about z axis of given angle to the current rotation matrix public void RotateAboutZAxis(double angleRad) Parameters angleRad double rotation angle about Z axis Remarks unit test"
  },
  "api/SearchAThing.Sci.Triangle3D.html": {
    "href": "api/SearchAThing.Sci.Triangle3D.html",
    "title": "Class Triangle3D | netcore-sci",
    "keywords": "Class Triangle3D Namespace SearchAThing.Sci Assembly netcore-sci.dll helper class to hold triangle info, used in conjunction with LibTessDotNet methods. public class Triangle3D Inheritance object Triangle3D Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Triangle3D(Vector3D, Vector3D, Vector3D) public Triangle3D(Vector3D v1, Vector3D v2, Vector3D v3) Parameters v1 Vector3D v2 Vector3D v3 Vector3D Properties CS (cached) on demand coordinate system with origin V1. public CoordinateSystem3D CS { get; } Property Value CoordinateSystem3D Segments Retrieve (v1,v2), (v2,v3), (v3,v1) triangle segments. public IEnumerable<Line3D> Segments { get; } Property Value IEnumerable<Line3D> V1 public Vector3D V1 { get; } Property Value Vector3D V2 public Vector3D V2 { get; } Property Value Vector3D V3 public Vector3D V3 { get; } Property Value Vector3D Methods Contains(Vector3D) States if a point is in this triangle. public bool Contains(Vector3D point) Parameters point Vector3D Returns bool Intersect(double, Triangle3D) intersect this triangle with given other, returning intersection line ( eventyally a point line ) or null if no intersects at all. public Line3D? Intersect(double tol, Triangle3D other) Parameters tol double other Triangle3D Returns Line3D IsParallelTo(double, Triangle3D) states if this triangle parallel to other given. public bool IsParallelTo(double tol, Triangle3D other) Parameters tol double other Triangle3D Returns bool RestrictTo(double, Line3D) Restrict given this triangle coplanar line to be enclosed in the triangle shape. public Line3D? RestrictTo(double tol, Line3D line) Parameters tol double Length comparision tolerance. line Line3D This triangle coplanar line. Returns Line3D Segment of line enclosed in this triangle."
  },
  "api/SearchAThing.Sci.Vector3D.html": {
    "href": "api/SearchAThing.Sci.Vector3D.html",
    "title": "Class Vector3D | netcore-sci",
    "keywords": "Class Vector3D Namespace SearchAThing.Sci Assembly netcore-sci.dll can be used to describe a wcs point or a vector x,y,z components from some reference origin public class Vector3D : Geometry Inheritance object Geometry Vector3D Inherited Members Geometry.GeomType object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Extension Methods Ext.Sqrt(Vector3D) Constructors Vector3D() zero vector [JsonConstructor] public Vector3D() Remarks unit test Vector3D(Vector3D) build a copy of given vector public Vector3D(Vector3D v) Parameters v Vector3D Vector3D(double, double) build a vector (x,y,0) by given components public Vector3D(double x, double y) Parameters x double y double Remarks unit test Vector3D(double, double, double) build a vector by given components public Vector3D(double x, double y, double z) Parameters x double y double z double Remarks unit test Vector3D(double[]) build a vector (x,y,0) or (x,y,z) from given 2 or 3 doubles public Vector3D(double[] arr) Parameters arr double[] Remarks unit test Vector3D(string) parse cad id string (eg. \"X = 4.11641325 Y = 266.06066703 Z = 11.60392802\") constructing a point public Vector3D(string cad_id_string) Parameters cad_id_string string cad id string Remarks unit test Fields One one vector (1,1,1) public static readonly Vector3D One Field Value Vector3D XAxis xaxis vector (1,0,0) public static readonly Vector3D XAxis Field Value Vector3D Remarks unit test YAxis yaxis vector (0,1,0) public static readonly Vector3D YAxis Field Value Vector3D Remarks unit test ZAxis zaxis vector (0,0,1) public static readonly Vector3D ZAxis Field Value Vector3D Remarks unit test Zero zero vector (0,0,0) public static readonly Vector3D Zero Field Value Vector3D Remarks unit test Properties A0QCadScript public string A0QCadScript { get; } Property Value string CadScript cad script for this vector as wcs point public string CadScript { get; } Property Value string CadScriptLine cad script for a line (0,0,0) to this vector public string CadScriptLine { get; } Property Value string CadScriptLineFrom cad script for a line departing from this wcs point public string CadScriptLineFrom { get; } Property Value string Coordinates enumerate coordinates public IEnumerable<double> Coordinates { get; } Property Value IEnumerable<double> Remarks unit test DxfEntity Create dxf point entity suitable for netDxf addEntity. ( Geometry DxfEntity implementation ) public override EntityObject DxfEntity { get; } Property Value EntityObject Remarks unit test GeomFrom This vector. ( Geometry GeomFrom implementation ) [JsonIgnore] public override Vector3D GeomFrom { get; } Property Value Vector3D Remarks unit test GeomTo This vector. ( Geometry GeomTo implementation) [JsonIgnore] public override Vector3D GeomTo { get; } Property Value Vector3D Remarks unit test IsZeroLength states if this is a zero vector public bool IsZeroLength { get; } Property Value bool Remarks unit test this[int] indexed vector component public double this[int index] { get; } Parameters index int Property Value double Length Length of this vector. ( Geometry Length implementation ) public override double Length { get; } Property Value double Remarks unit test Max max between X,Y,Z public double Max { get; } Property Value double MidPoint public override Vector3D MidPoint { get; } Property Value Vector3D Min min between X,Y,Z public double Min { get; } Property Value double Vertexes Enumerable with only this vector. ( Geometry Vertexes implementation ) [JsonIgnore] public override IEnumerable<Vector3D> Vertexes { get; } Property Value IEnumerable<Vector3D> Remarks unit test X X vector component public double X { get; } Property Value double Remarks unit test Y Y vector component public double Y { get; } Property Value double Remarks unit test Z Z vector component public double Z { get; } Property Value double Remarks unit test Methods Abs() compute (Abs(v.x), Abs(v.y), Abs(v.z)) public Vector3D Abs() Returns Vector3D AngleRad(double, Vector3D) angle between this and given vector public double AngleRad(double tol, Vector3D to) Parameters tol double length tolerance to test vector equalities ( use Constants.NormalizedLengthTolerance when comparing normalized vectors ) to Vector3D other vector Returns double angle between two vectors (rad) Remarks unit test AngleToward(double, Vector3D, Vector3D) compute angle required to make this point go to the given one if rotate right-hand around given reference axis public double AngleToward(double tol, Vector3D to, Vector3D refAxis) Parameters tol double length tolerance ( use Constants.NormalizedLengthTolerance if working with normalized vectors ) to Vector3D point toward rotate this one refAxis Vector3D reference axis to make right-hand rotation of this point toward given one Returns double angle (rad) Axis(int) retrieve wcs axis by given index public static Vector3D Axis(int ord) Parameters ord int 0:(1,0,0) 1:(0,1,0) 2:(0,0,1) Returns Vector3D Remarks unit test BBox(double) Compute bbox of this point. ( Geometry BBox implementation ). public override BBox3D BBox(double tol) Parameters tol double length tolerance Returns BBox3D Remarks unit test Clamp(Vector3D, Vector3D) return clamped Vector3D between [min,max] interval public Vector3D Clamp(Vector3D min, Vector3D max) Parameters min Vector3D min value admissible max Vector3D max value admissible Returns Vector3D given vector with xyz components clamped to corresponding min,max components Colinear(double, Vector3D) states if this vector is colinear to the given one public bool Colinear(double tol, Vector3D other) Parameters tol double geometric tolerance other Vector3D other vector Returns bool ColinearScalarOffset(double, Vector3D, Vector3D) retrieve signed offset of this point respect given origin point in the given normalized direction v. precondition: vector v must colinear to (this-origin) and must already normalized public double ColinearScalarOffset(double tol, Vector3D origin, Vector3D v) Parameters tol double origin Vector3D v Vector3D Returns double Concordant(double, Vector3D) states if this vector concord to the given one NOTE: it does not test two vectors are parallels ( precondition must meet ) public bool Concordant(double tol, Vector3D other) Parameters tol double geometric tolerance ( Constants.NormalizedLengthTolerance if comparing normalized vectors ) other Vector3D other vector Returns bool ConcordantColinear(double, Vector3D) statis if this vector is concordant and colinear to the given one public bool ConcordantColinear(double tol, Vector3D other) Parameters tol double geometric tolerance ( Constants.NormalizedLengthTolerance if comparing normalized vectors ) other Vector3D other vector Returns bool Copy() create copy of this geometry. public override Geometry Copy() Returns Geometry Remarks it's required to call base.CopyFrom(other) to ensure geometry properties to be copied. CrossProduct(Vector3D) Cross product ( not normalized ) ; a x b = |a| |b| sin(alfa) N ; a x b = | x y z | | ax ay az | | bx by bz | reference ; public Vector3D CrossProduct(Vector3D other) Parameters other Vector3D other vector Returns Vector3D Remarks unit test Debug(string) debug to console with optional prefix public Vector3D Debug(string prefix = \"\") Parameters prefix string optional prefix Returns Vector3D vector DisambiguatedPoints(double, Vector3D) returns p1 and p2 if one of the p1 coords are less than corresponding p2 coords ; elsewhere returns p2 and p1. Useful to obtain the same sequence order independant from order of operands. public IEnumerable<Vector3D> DisambiguatedPoints(double tol, Vector3D other) Parameters tol double other Vector3D Returns IEnumerable<Vector3D> Distance(Vector3D) compute distance between this point and the other given public double Distance(Vector3D other) Parameters other Vector3D Returns double Remarks unit test Distance(double, Line3D) compute perpendicular(min) distance of this point from given line public double Distance(double tol, Line3D other) Parameters tol double length tolerance ( used to check if point contained in line ) other Line3D line Returns double Remarks unit test Divide(int, bool) Divide this point returning itself. ( Geometry Divide implementation ) public override IEnumerable<Vector3D> Divide(int cnt, bool include_endpoints = false) Parameters cnt int include_endpoints bool Returns IEnumerable<Vector3D> Remarks unit test DotProduct(Vector3D) compute dot product of this vector for the given one a b = |a| |b| cos(alfa) public double DotProduct(Vector3D other) Parameters other Vector3D second vector Returns double Remarks unit test EqualsAutoTol(Vector3D) check if this vector equals the given one component by component using EqualsAutoTol public bool EqualsAutoTol(Vector3D other) Parameters other Vector3D Returns bool Remarks unit test EqualsTol(double, Vector3D?) checks vector component equality vs other given public bool EqualsTol(double tol, Vector3D? other) Parameters tol double geometric tolerance ( note: use Constants.NormalizedLengthTolerance ) other Vector3D vector to compare to this Returns bool Remarks unit test EqualsTol(double, double, double) checks only x,y public bool EqualsTol(double tol, double x, double y) Parameters tol double geometric tolerance ( note: use Constants.NormalizedLengthTolerance ) x double x coord y double y coord Returns bool Remarks unit test EqualsTol(double, double, double, double) checks vector component equality vs other given public bool EqualsTol(double tol, double x, double y, double z) Parameters tol double geometric tolerance ( note: use Constants.NormalizedLengthTolerance ) x double x coord y double y coord z double z coord Returns bool Remarks unit test From2DCoords(params double[]) Create an array of Vector3D from given list of 2d coords ( eg. { 100, 200, 300, 400 } will create follow list of vector3d = { (100,200,0), (300,400,0) } public static List<Vector3D> From2DCoords(params double[] coords) Parameters coords double[] Returns List<Vector3D> From3DCoords(params double[]) Create an array of Vector3D from given list of 3d coords ( eg. { 100, 200, 10, 300, 400, 20 } will create follow list of vector3d = { (100,200,10), (300,400,20) } public static List<Vector3D> From3DCoords(params double[] coords) Parameters coords double[] Returns List<Vector3D> FromString(string) parse vector3d from string format \"(x y z)\" or \"(x,y,z)\" invariant type public static Vector3D FromString(string str) Parameters str string Returns Vector3D FromStringArray(string) parse vector3d from array \"(x1,y1,z1);(x2,y2,z2)\"; an appropriate string can be generated with StringRepresentation extension. public static IEnumerable<Vector3D> FromStringArray(string str) Parameters str string Returns IEnumerable<Vector3D> FromTxtPointsList(string, CultureInfo?) retrieve list of Vector3D by reading from a txt file, for example: -53.54533794,-141.18745265 18.20103872,-149.89903999 85.77777676,-124.27056375 notes: supports also third coord (Z) ; whitespace are removed ; empty lines are removed public static IEnumerable<Vector3D> FromTxtPointsList(string txt, CultureInfo? culture = null) Parameters txt string txt data to read culture CultureInfo culture for number parsing (default: invariant) Returns IEnumerable<Vector3D> enumerable of Vector3D corresponding to data GeomEquals(double, Geometry, bool) states if this geom equals to given other public override bool GeomEquals(double tol, Geometry other, bool checkSense = false) Parameters tol double length tolerance other Geometry other geom checkSense bool if false two geometry with different sense but same space coverage are considered equals Returns bool GeomIntersect(double, Geometry, GeomSegmentMode, GeomSegmentMode) find intersections between this and another geometry resulting in zero or more geometries. public override IEnumerable<Geometry> GeomIntersect(double tol, Geometry other, GeomSegmentMode thisSegmentMode, GeomSegmentMode otherSegmentMode) Parameters tol double other Geometry thisSegmentMode GeomSegmentMode if this is Line3D specifies how to consider otherSegmentMode GeomSegmentMode if other is Line3D specifies how to consider Returns IEnumerable<Geometry> GetOrd(OrdIdx) retrieve the component (0:X, 1:Y, 2:Z) public double GetOrd(OrdIdx ord) Parameters ord OrdIdx Returns double Remarks unit test GetOrd(int) retrieve the component (0:X, 1:Y, 2:Z) public double GetOrd(int ord) Parameters ord int Returns double Remarks unit test IsParallelTo(double, Vector3D) Note: tol must be Constants.NormalizedLengthTolerance if comparing normalized vectors public bool IsParallelTo(double tol, Vector3D other) Parameters tol double other Vector3D Returns bool IsPerpendicular(Vector3D) states is this vector is perpendicular to the given one public bool IsPerpendicular(Vector3D other) Parameters other Vector3D other vector Returns bool Remarks unit test LineDir(Vector3D, double, bool) build Line3D from this to (this+dir*len) public Line3D LineDir(Vector3D dir, double len, bool applyDirNorm = false) Parameters dir Vector3D direction len double length of the line applyDirNorm bool apply normalization to given direction ( default:false ) Returns Line3D Line3D from this to (this+dir*len) LineTo(Vector3D) build Line3D from this to given to public Line3D LineTo(Vector3D to) Parameters to Vector3D line3d to point Returns Line3D build Line3D from this to given to LineV(Vector3D) build Line3D from this to (this+vector) public Line3D LineV(Vector3D vector) Parameters vector Vector3D vector to add this to obtain line to Returns Line3D Line3D from this to (this+given vector) Mirror(Line3D) mirror this point about given axis public Vector3D Mirror(Line3D axis) Parameters axis Line3D Returns Vector3D Move(Vector3D) public override Geometry Move(Vector3D delta) Parameters delta Vector3D Returns Geometry Normalized() create a normalized version of this vector public Vector3D Normalized() Returns Vector3D Remarks unit test Project(CoordinateSystem3D, bool) wcs coord of projected coord to the given cs public Vector3D Project(CoordinateSystem3D cs, bool evalCSOrigin = true) Parameters cs CoordinateSystem3D cs to project evalCSOrigin bool if true cs origin will subtracted before transform, then readded to obtain wcs point Returns Vector3D Project(Line3D) project this point to the given line considered as infinite line public Vector3D Project(Line3D line) Parameters line Line3D line to project the point onto Returns Vector3D projected point onto the line ( perpendicularly ) Project(Vector3D) project this vector to the given one public Vector3D Project(Vector3D to) Parameters to Vector3D other vector Returns Vector3D projected vector ( will be colinear to the given one ) Remarks unit test QCadScript(bool) public string QCadScript(bool final = true) Parameters final bool Returns string Random(int, double, double, double, double, double, double, int, Random?) Span a set of qty vector3d with random coord between given range. Optionally a seed can be specified for rand or Random obj directly ( in latter case seed aren't used ) public static IEnumerable<Vector3D> Random(int qty, double xmin, double xmax, double ymin, double ymax, double zmin, double zmax, int seed = 0, Random? random = null) Parameters qty int xmin double xmax double ymin double ymax double zmin double zmax double seed int random Random Returns IEnumerable<Vector3D> Random(int, double, int) public static IEnumerable<Vector3D> Random(int N, double L, int seed = 0) Parameters N int L double seed int Returns IEnumerable<Vector3D> Rel(Vector3D) create a vector relative to given origin from this point and given origin public Vector3D Rel(Vector3D origin) Parameters origin Vector3D origin to make this point relative to Returns Vector3D vector RotateAboutAxis(Line3D, double) rotate this point right-hand around given segment using quaternion public Vector3D RotateAboutAxis(Line3D axisSegment, double angleRad) Parameters axisSegment Line3D rotation axis segment angleRad double angle (rad) of rotation Returns Vector3D rotated point RotateAboutAxis(Vector3D, double) rotate this point right-hand around given axis using quaternion public Vector3D RotateAboutAxis(Vector3D axis, double angleRad) Parameters axis Vector3D rotation axis angleRad double angle (rad) of rotation Returns Vector3D rotated point RotateAboutXAxis(double) rotate this point around x-axis using quaternion public Vector3D RotateAboutXAxis(double angleRad) Parameters angleRad double angle (rad) of rotation Returns Vector3D rotated point RotateAboutYAxis(double) rotate this point around y-axis using quaternion public Vector3D RotateAboutYAxis(double angleRad) Parameters angleRad double angle (rad) of rotation Returns Vector3D rotated point RotateAboutZAxis(double) rotate this point around z-axis using quaternion public Vector3D RotateAboutZAxis(double angleRad) Parameters angleRad double angle (rad) of rotation Returns Vector3D rotated point RotateAs(double, Vector3D, Vector3D, double, double) Note: tol must be Constants.NormalizedLengthTolerance if comparing normalized vectors rotation from-to will be multiplied for given angleFactor ( default 1.0 ) public Vector3D RotateAs(double tol, Vector3D from, Vector3D to, double angleFactor = 1, double angleAddictionalRad = 0) Parameters tol double geometric tolerance ( use Constants.NormalizedLengthTolerance if vectors are normalized ) from Vector3D point from describing rotation path to Vector3D point to describing rotation path angleFactor double optional angle rotation scaler angleAddictionalRad double optional angle (rad) component (added after angleFactor scaler) Returns Vector3D Scalar(double, double, double) Scalar multiply each components public Vector3D Scalar(double xs, double ys, double zs) Parameters xs double ys double zs double Returns Vector3D ScaleAbout(Vector3D, Vector3D) Scale this point about the given origin with the given factor as (sx,sy,sz). public Vector3D ScaleAbout(Vector3D origin, Vector3D factor) Parameters origin Vector3D factor Vector3D Returns Vector3D ScaleAbout(Vector3D, double) Scale this point about the given origin with the given factor. public Vector3D ScaleAbout(Vector3D origin, double factor) Parameters origin Vector3D factor double Returns Vector3D Set(OrdIdx, double) create a point copy of this one with component changed public Vector3D Set(OrdIdx ordIdx, double value) Parameters ordIdx OrdIdx component to change ( 0:x 1:y 2:z ) value double value to assign to the component Returns Vector3D new vector with component changed Set(int, double) create a point copy of this one with component changed public Vector3D Set(int ordIdx, double value) Parameters ordIdx int component to change ( 0:x 1:y 2:z ) value double value to assign to the component Returns Vector3D new vector with component changed SetX(double) create new vector with X changed public Vector3D SetX(double value) Parameters value double input vector Returns Vector3D output vector with X changed SetY(double) create new vector with Y changed public Vector3D SetY(double value) Parameters value double input vector Returns Vector3D output vector with Y changed SetZ(double) create new vector with Z changed public Vector3D SetZ(double value) Parameters value double input vector Returns Vector3D output vector with Z changed Sign() compute (Sign(v.x), Sign(v.y), Sign(v.z)) public Vector3D Sign() Returns Vector3D Split(double, IEnumerable<Vector3D>) split geometry in given break points. precondition: breaks must lie on the geometry perimeter public override IEnumerable<Geometry> Split(double tol, IEnumerable<Vector3D> breaks) Parameters tol double breaks IEnumerable<Vector3D> Returns IEnumerable<Geometry> SquaredDistance(Vector3D) (other.X - this.X)^2 + (other.Y - this.Y)^2 + (other.Z - this.Z)^2 public double SquaredDistance(Vector3D other) Parameters other Vector3D Returns double StringRepresentation() string invariant representation \"(x,y,z)\" public string StringRepresentation() Returns string ToDeg() convert xyz from rad to deg public Vector3D ToDeg() Returns Vector3D xyz deg angles ToDxfPoint() create dxf point from given vector3d public Point ToDxfPoint() Returns Point ToDxfVector2() convert to (netdxf) discarding z public Vector2 ToDxfVector2() Returns Vector2 ToDxfVector3() convert to (netdxf) discarding z public Vector3 ToDxfVector3() Returns Vector3 ToNVector2() convert to (system.numerics) Vector2 ( casting double to float, discarding z ) public Vector2 ToNVector2() Returns Vector2 ToNVector3() convert to (system.numerics) Vector3 ( casting double to float ) public Vector3 ToNVector3() Returns Vector3 ToPoint() To point (double x, double y) public Point ToPoint() Returns Point ToRad() convert xyz from deg to rad public Vector3D ToRad() Returns Vector3D xyz rad angles ToString() string invariant representation \"(x,y,z)\" w/3 decimal places public override string ToString() Returns string ToString(double) hash string with given tolerance public string ToString(double tol) Parameters tol double Returns string ToString(int) string invariant representation \"(x,y,z)\" w/given digits public string ToString(int digits = 3) Parameters digits int Returns string ToUCS(CoordinateSystem3D, bool) Convert this wcs point to given cs coord public Vector3D ToUCS(CoordinateSystem3D cs, bool evalCSOrigin = true) Parameters cs CoordinateSystem3D dest CS evalCSOrigin bool if true CS origin will subtracted before transform Returns Vector3D ToWCS(CoordinateSystem3D, bool) Convert this ucs considered vector using given cs to the wcs public Vector3D ToWCS(CoordinateSystem3D cs, bool evalCSOrigin = true) Parameters cs CoordinateSystem3D ucs point evalCSOrigin bool if true CS origin will added after transform Returns Vector3D Transform(Matrix4x4) return this vector transformed by given (float) transformation public Vector3D Transform(Matrix4x4 transform) Parameters transform Matrix4x4 Returns Vector3D XYDistance(Vector3D) compute distance of this point from the given in 2d ( x,y ) without consider z component public double XYDistance(Vector3D other) Parameters other Vector3D other point Returns double Remarks unit test Operators operator +(Vector3D, Vector3D) sum public static Vector3D operator +(Vector3D a, Vector3D b) Parameters a Vector3D b Vector3D Returns Vector3D operator /(Vector3D, double) scalar div public static Vector3D operator /(Vector3D v, double s) Parameters v Vector3D s double Returns Vector3D operator /(double, Vector3D) scalar div public static Vector3D operator /(double s, Vector3D v) Parameters s double v Vector3D Returns Vector3D implicit operator Vector3D(Vec3) Convert given LibTessDotNet.Vec3 to Vector3D public static implicit operator Vector3D(Vec3 v) Parameters v Vec3 input vector Returns Vector3D implicit operator Vector3(Vector3D) Convert given Vector3D to System.Numerics.Vector3 public static implicit operator Vector3(Vector3D v) Parameters v Vector3D input vector Returns Vector3 Remarks double to float conversion will be done implicit operator Vector3(Vector3D) Convert given Vector3D to (netdxf) Vector3 public static implicit operator Vector3(Vector3D v) Parameters v Vector3D Returns Vector3 implicit operator Vector3D(Vector2) convert given (System.Numerics) Vector2 to a Vector3D ( with z=0 ) public static implicit operator Vector3D(Vector2 v) Parameters v Vector2 Returns Vector3D implicit operator Vector3D(Vector3) Convert given System.Numerics.Vector3 to Vector3D public static implicit operator Vector3D(Vector3 v) Parameters v Vector3 input vector Returns Vector3D implicit operator Vector3D(Vector2) convert given (netdxf) Vector2 to a Vector3D ( assume z=0 ) public static implicit operator Vector3D(Vector2 v) Parameters v Vector2 Returns Vector3D implicit operator Vector3D(Vector3) Convert given (netdxf) Vector3 to Vector3D public static implicit operator Vector3D(Vector3 v) Parameters v Vector3 Returns Vector3D operator *(Vector3D, Vector3D) scalar multiply vector components V1 * V2 = (V1.x * V2.x, V1.y * V2.y, V1.z * V2.z) public static Vector3D operator *(Vector3D v1, Vector3D v2) Parameters v1 Vector3D v2 Vector3D Returns Vector3D operator *(Vector3D, double) scalar mul public static Vector3D operator *(Vector3D v, double s) Parameters v Vector3D s double Returns Vector3D operator *(double, Vector3D) scalar mul public static Vector3D operator *(double s, Vector3D v) Parameters s double v Vector3D Returns Vector3D operator -(Vector3D, Vector3D) sub public static Vector3D operator -(Vector3D a, Vector3D b) Parameters a Vector3D b Vector3D Returns Vector3D operator -(Vector3D) negate public static Vector3D operator -(Vector3D a) Parameters a Vector3D Returns Vector3D"
  },
  "api/SearchAThing.Sci.Vector3DEqualityComparer.html": {
    "href": "api/SearchAThing.Sci.Vector3DEqualityComparer.html",
    "title": "Class Vector3DEqualityComparer | netcore-sci",
    "keywords": "Class Vector3DEqualityComparer Namespace SearchAThing.Sci Assembly netcore-sci.dll helper class to compare vector3d set using given tolerance public class Vector3DEqualityComparer : IEqualityComparer<Vector3D> Inheritance object Vector3DEqualityComparer Implements IEqualityComparer<Vector3D> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Vector3DEqualityComparer(double) public Vector3DEqualityComparer(double _tol) Parameters _tol double Methods Equals(Vector3D?, Vector3D?) public bool Equals(Vector3D? x, Vector3D? y) Parameters x Vector3D y Vector3D Returns bool GetHashCode(Vector3D) public int GetHashCode(Vector3D obj) Parameters obj Vector3D Returns int"
  },
  "api/SearchAThing.Sci.Vector3DWithOrder.html": {
    "href": "api/SearchAThing.Sci.Vector3DWithOrder.html",
    "title": "Class Vector3DWithOrder | netcore-sci",
    "keywords": "Class Vector3DWithOrder Namespace SearchAThing.Sci Assembly netcore-sci.dll support class for DistinctKeepOrder extension public class Vector3DWithOrder Inheritance object Vector3DWithOrder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Vector3DWithOrder(Vector3D, int) public Vector3DWithOrder(Vector3D v, int order) Parameters v Vector3D order int Properties Order public int Order { get; } Property Value int Vector public Vector3D Vector { get; } Property Value Vector3D"
  },
  "api/SearchAThing.Sci.Vector3DWithOrderEqualityComparer.html": {
    "href": "api/SearchAThing.Sci.Vector3DWithOrderEqualityComparer.html",
    "title": "Class Vector3DWithOrderEqualityComparer | netcore-sci",
    "keywords": "Class Vector3DWithOrderEqualityComparer Namespace SearchAThing.Sci Assembly netcore-sci.dll helper class to compare vector3d in a distinct operation retaining original order, used by DistinctKeepOrder() public class Vector3DWithOrderEqualityComparer : IEqualityComparer<Vector3DWithOrder> Inheritance object Vector3DWithOrderEqualityComparer Implements IEqualityComparer<Vector3DWithOrder> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Vector3DWithOrderEqualityComparer(Vector3DEqualityComparer) public Vector3DWithOrderEqualityComparer(Vector3DEqualityComparer _cmp) Parameters _cmp Vector3DEqualityComparer Methods Equals(Vector3DWithOrder?, Vector3DWithOrder?) public bool Equals(Vector3DWithOrder? x, Vector3DWithOrder? y) Parameters x Vector3DWithOrder y Vector3DWithOrder Returns bool GetHashCode(Vector3DWithOrder) public int GetHashCode(Vector3DWithOrder obj) Parameters obj Vector3DWithOrder Returns int"
  },
  "api/SearchAThing.Sci.html": {
    "href": "api/SearchAThing.Sci.html",
    "title": "Namespace SearchAThing.Sci | netcore-sci",
    "keywords": "Namespace SearchAThing.Sci Classes Arc3D base geometry for arc 3d entities. the CS origin is the Center of the arc. the CS basex, basey forms the arc plane. angles start, end are normalized [0,2pi) measured as angle from the basex right-hand rotating around cs basez. the arc coverage goes from the angle start point toward angle end point right-hand rotating arond cs basez. while the CS right hand rule allow to know the effective arc coverage Sense information allow to know the effective edge orientation. Arc3DEqualityComparer checks if arcs share same plane, origin, radius, angle start-end BBox3D Bounding Box. Initially empty, each added point will increase the extension if min or max exceed actual bbox limits. It works within wcs. Circle3D Specialized version of Arc3D with StartAngle=0 and EndAngle=2PI ComputationQueue<T> helper circular queue manager for computation. at constructor the maxSize ( default=3 ) can be specified to allow retrieval of previous computed items Constants CoordinateSystem3D CS with origin and basex, basey, basez orthonormal vectors. WCS coord can be translated to this cs using ToUCS() method. UCS coord can be translated back to wcs using ToWCS() method. DQuaternion Quaternion implementation using doubles for purpose of Vector3D.RotateAboutAxis and Vector3D.RotateAs references: http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/index.htm https://www.3dgep.com/understanding-quaternions/ http://www.ncsa.illinois.edu/People/kindr/emtc/quaternions/ DVector3EqualityComparer helper class to compare vector3d set using given tolerance DiscreteSpaceItemComparer<T> comparer to search in DiscreteSpace DiscreteSpaceItem<T> base item for DiscreteSpace DiscreteSpace<T> organize given item list into a discretized space to allow fast query of elements in a space region DoubleEqualityComparer helper class to compare a set of doubles by using given tolerance Edge interface implemented by some type of geometries used in Loop such as Line3D, Arc3D and Circle3D Ext netcore-sci extension methods Face Planar face with one (outer) or more loops (inners) Geometry base abstract type for geometries such as Vector3D, Line3D, Arc3D and Circle3D Int64Map Scan a given domain of doubles, determine the midpoint ( Origin ) and using the given tolerance it tests for integrity in conversion between values from double to Int64 and vice-versa. It can generate a Int64MapExceptionRange. Int64MapExceptionRange LUT Lookup Table genertor Line3D Defines a line by an application point (From) and an extension from there (V). To is computed as From+V. Line can be built by givin From and To, or From and V using specialized constructor with Line3DConstructMode. Line can be built from a point using LineTo(), LineV() or LineDir() extension methods. Line3DEqualityComparer equality comparer helper for Line3D types Loop planar edges loop containing line and arcs LoopEqualityComparer Matrix3D basic matrix3d with 3x3 double elements and operations to allow arithmetic and 3d linear equation resolution. NVector3EqualityComparer helper class to compare vector3d set using given tolerance NormalizedAngleComparer normalized angles in range [StartAngle, EndAngle] comparer Example: start:1.25Ï€ end:0.5Ï€ the set { 0.25Ï€, 0.75Ï€ } sorts to { 0.75Ï€, 0.25Ï€ } Precondition: constructor start, end angles and compare method arguments must normalized [0,2PI) Plane3D encapsulate a CS to define a plane3d Plane3DRegion region of a plane3d delimited by a set of coplanar points PythonException PythonPipe Helper to invoke python and retrieve results. PythonPipeOptions Toolkit netcore-sci toolkit static methods Toolkit.SciPropertiesResolver addictional json resolver to ignore some Vector3D, Line3D properties during serialization without affecting source code Toolkit.UnitJsonConverter<TUnitType> json converter to write unit using abbrev Transform3D Use quaternion to append rotate transformations Triangle3D helper class to hold triangle info, used in conjunction with LibTessDotNet methods. Vector3D can be used to describe a wcs point or a vector x,y,z components from some reference origin Vector3DEqualityComparer helper class to compare vector3d set using given tolerance Vector3DWithOrder support class for DistinctKeepOrder extension Vector3DWithOrderEqualityComparer helper class to compare vector3d in a distinct operation retaining original order, used by DistinctKeepOrder() Structs NumbersStatNfo statistical info about number set Enums CircleTangentType CoordinateSystem3DAutoEnum EdgeEnd Face.BooleanMode GeomSegmentMode GeometryType Line3DConstructMode LineIntersectBehavior LoopContainsEdgeMode LoopContainsPointMode OrdIdx PythonPipeOnErrorResultEnum SmartCsMode Delegates Ext.HatchSetterDelegate Toolkit.WalkEdgeStopConditionDelegate"
  },
  "data/pages/mainpage-doc.html": {
    "href": "data/pages/mainpage-doc.html",
    "title": "| netcore-sci",
    "keywords": "\\mainpage netcore-sci This is the API documentation of the netcore-sci library. Sources and Examples Namespace Toolkit Extensions Description Toolkit Extensions Linear algebra and other sci stuff."
  },
  "index.html": {
    "href": "index.html",
    "title": "netcore-sci | netcore-sci",
    "keywords": "netcore-sci api"
  }
}